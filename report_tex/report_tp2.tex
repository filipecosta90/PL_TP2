%
% Layout retirado de http://www.di.uminho.pt/~prh/curplc09.html#notas
%

\documentclass{report}
\usepackage[portuges]{babel}
\usepackage[latin1]{inputenc}

\usepackage{url}
\usepackage{listings}
\lstset{
  basicstyle=\small,
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    breaklines=true,
    frame=tB,
    mathescape=true,
    escapeinside={(*@}{@*)}
}

    \usepackage{xspace}
    \usepackage{graphicx}
    \usepackage{float}

    \parindent=0pt
    \parskip=2pt

    \setlength{\oddsidemargin}{-1cm}
    \setlength{\textwidth}{18cm}
    \setlength{\headsep}{-1cm}
    \setlength{\textheight}{23cm}

    \def\darius{\textsf{Darius}\xspace}
    \def\java{\texttt{Java}\xspace}
    \def\pe{\emph{Publicaï¿½ï¿½o Eletrï¿½nica}\xspace}


    \title{Processamento de Linguagens (3ï¿½ ano de Curso)\\ \textbf{Trabalho Prï¿½tico N 2}\\ Relatï¿½rio de Desenvolvimento}
    \author{Filipe Costa Oliveira\\ a57816  }
    \date{\today}

    \begin{document}

    \maketitle

    \newpage

    \tableofcontents

    \chapter{Introduï¿½ï¿½o} \label{intro}

    O presente trabalho prï¿½tico foca-se no desenvolvimento de  um compilador, que tem como fonte uma linguagem de alto nï¿½vel (tambï¿½m esta desenvolvida especificamente para este trabalho prï¿½tico) , gerando cï¿½digo para uma mï¿½quina de stack virtual. \par 
    Um compilador comum divide o processo de traduï¿½ï¿½o em vï¿½rias fases. Para o propï¿½sito especï¿½fico desta unidade curricular iremos focar-nos nas seguintes:
    \begin{itemize}
    \item 1ï¿½ Fase de traduï¿½ï¿½o -- Anï¿½lise Lï¿½xica, que agrupa sequï¿½ncias de caracteres em tokens. Recorreremos nesta fase ï¿½ definiï¿½ï¿½o das expressï¿½es regulares que permitem definir os tokens.
    \item 2ï¿½ Fase de traduï¿½ï¿½o --  Reconhecimento(Parsing) da estrutura gramatical do programa, atravï¿½s do agrupamento dos tokens em produï¿½ï¿½es. Recorreremos ï¿½ definiï¿½ï¿½o de uma gramï¿½tica independente de contexto por forma a definir as estruturas de programa vï¿½lidas a reconhecer pelo parser. Denote que juntamente com o parsing ï¿½ realizada a anï¿½lise semï¿½ntica, assim como a geraï¿½ï¿½o de cï¿½digo associando regras ï¿½s produï¿½ï¿½es anteriormente descritas.
    \end{itemize} 
    Comeï¿½aremos portanto por definir uma linguagem de programaï¿½ï¿½o imperativa simples, que chamaremos Algebra. A Algebra permitirï¿½:
    \begin{itemize}
    \item declarar e manusear variï¿½veis atï¿½micas do tipo inteiro, com os quais se podem realizar as habituais operaï¿½ï¿½es
aritmï¿½ticas, relacionais e lï¿½gicas.
    \item declarar e manusear variï¿½veis estruturadas do tipo array (a 1 ou 2 dimensï¿½es) de inteiros, em relaï¿½ï¿½o aos quais  ï¿½ apenas permitida a operaï¿½ï¿½o de indexaï¿½ï¿½o. Aos arrays de duas dimensï¿½es, por se tratar de uma linguagem algï¿½brica, chamaremos matrizes, dada a fï¿½cil associaï¿½ï¿½o a este tipo de variï¿½vel ï¿½ sua definiï¿½ï¿½o anï¿½loga da ï¿½lgebra linear.
    \item efetuar instruï¿½ï¿½es algorï¿½tmicas bï¿½sicas como a atribuiï¿½ï¿½o de expressï¿½es a variï¿½veis.
\item ler do standard input e escrever no standard output.
\item  efetuar instruï¿½ï¿½es para controlo do fluxo de execuï¿½ï¿½o -- condicional e cï¿½clica -- que possam ser aninhadas.
\item definir e invocar subprogramas sem parï¿½metros mas que possam retornar um resultado atï¿½mico.
    \end{itemize} 
  
Na nossa linguagem de programaï¿½ï¿½o por questï¿½es de estruturaï¿½ï¿½o e percepï¿½ï¿½o, teremos como premissa que as varï¿½aveis deverï¿½o ser declaradas no inï¿½cio do programa, nï¿½o podendo haver re-declaraï¿½ï¿½es, nem utilizaï¿½ï¿½es sem declaraï¿½ï¿½o prï¿½via. Nï¿½o serï¿½ permitida a declaraï¿½ï¿½o e associaï¿½ï¿½o de um valor inteiro na mesma instruï¿½ï¿½o. Achamos essa soluï¿½ï¿½o pouco elegante. Assim, todas as variï¿½veis terï¿½o o valor zero apï¿½s a declaraï¿½ï¿½o.\par 

Serï¿½ desenvolvido portanto o compilador para a Algebra, com base na GIC criada acima e recurso ao Gerador Yacc/ Flex.
O compilador de Algebra irï¿½ gerar pseudo-cï¿½digo, Assembly da Mï¿½quina Virtual VM cuja documentaï¿½ï¿½o completa
estï¿½ disponibilizada em anexo.\par
Por forma a facilitar e validar o trabalho, ï¿½ medida que as funcionalidades forem descritas serï¿½o apensados  exemplos ilustrativos. \par 
Por fim, serï¿½o apresentados um conjunto de testes mais complexos(programas-fonte diversos e respectivo cï¿½digo produzido), que tentam testar de uma forma mais alargadas as funcionalidades da Algebra, sendo estes:
\begin{itemize}
\item lidos 3 nï¿½meros, escrever o maior deles.
 \item ler N (valor dado) nï¿½meros e calcular e imprimir o seu somatï¿½rio.
 \item contar e imprimir os nï¿½meros pares de uma sequï¿½ncia de N nï¿½meros dados.
 \item ler e armazenar os elementos de um vetor de comprimento N, imprimido os valores por ordem crescente apï¿½s fazer
a ordenaï¿½ï¿½o do array por trocas diretas.
 \item ler e armazenar os elementos de uma matriz NxM, calculando e imprimindo de seguida a mï¿½dia e mï¿½ximo dessa matriz.
\item  invocar e usar num programa  uma funï¿½ï¿½o.

    \end{itemize} 



    \chapter{Filtro de Texto com o Flex para ler uma ontologia descrita em OWL}
    \label{filtro}
    \section{Concepï¿½ï¿½o/desenho da Resoluï¿½ï¿½o}
    Tal como descrito anteriormente o problema serï¿½ resolvido com recurso ï¿½ ferramenta Flex. Pretendemos entï¿½o analisar uma ontologia descrita em OWL e  desenhar um grafo que ligue os conceitos entre si. Denote que a ontologia descrita em OWL nï¿½o passa de um dialecto XML, sendo portanto standardizada a forma como extraï¿½mos os dados. \par 
    Apesar da linguagem OWL ser extremamente extensa, apenas nos interessam a identificaï¿½ï¿½o das classes propriamente ditas e as relaï¿½ï¿½es entre estas, por forma a podermos desenhar o grafo que descreve a ontologia.\par 

    \section{Padrï¿½es de frases a encontrar, atravï¿½s de ER}
    Podemos considerar que no contexto do problema apresentado temos especial interesse nos axiomas de propriedades de dados, objectos, e classes.
    Assim, os axiomas passï¿½veis de serem incluï¿½dos no grafo serï¿½o:
    \begin{itemize}
    \item \textbf{Axiomas de Objetos}
    \begin{verbatim}
ObjectPropertyAxiom :=
SubObjectPropertyOf | EquivalentObjectProperties |
DisjointObjectProperties | InverseObjectProperties |
ObjectPropertyDomain | ObjectPropertyRange |
FunctionalObjectProperty | InverseFunctionalObjectProperty |
ReflexiveObjectProperty | IrreflexiveObjectProperty |
SymmetricObjectProperty | AsymmetricObjectProperty |
TransitiveObjectProperty
\end{verbatim}

\item \textbf{Axiomas de Dados}
\begin{verbatim}
DataPropertyAxiom :=
SubDataPropertyOf | EquivalentDataProperties | DisjointDataProperties |
DataPropertyDomain | DataPropertyRange | FunctionalDataProperty
\end{verbatim}
\item \textbf{Axiomas de Classe}
\begin{verbatim}
ClassAxiom := 
SubClassOf | EquivalentClasses | 
DisjointClasses | DisjointUnion
\end{verbatim}

\end{itemize}

que serï¿½o convertidos nas seguintes definiï¿½ï¿½es de expressï¿½es regulares a serem utilizadas no Flex:
\begin{lstlisting}
OBJ_PROP_AXIOM SubObjectPropertyOf|EquivalentObjectProperties|DisjointObjectProperties|InverseObjectProperties|ObjectPropertyDomain|ObjectPropertyRange|FunctionalObjectProper

DAT_PROP_AXIOM SubDataPropertyOf|EquivalentDataProperties|DisjointDataProperties|DataPropertyDomain|DataPropertyRange|FunctionalDataProperty

CLA_PROP_AXIOM SubClassOf|EquivalentClasses|DisjointClasses|DisjointUnion
\end{lstlisting}


\subsection{Comutaï¿½ï¿½o de contextos em Flex atravï¿½s de start conditions}
Por forma a realizar a correta anï¿½lise dos padrï¿½es de texto foi necessï¿½rio adicionar start conditions ï¿½s regras das expressï¿½es regulares. Deste modo, apresenta-se a lista de todas as start conditions utilizadas e sua breve descriï¿½ï¿½o:

\begin{lstlisting}

%x IN_PROP IN_DATA RELATION RELATION_BEG_END DATA DATA_BEG_END VALUE IN_CLASS CLASS_BEG_END 
\end{lstlisting}

\begin{itemize}
\item  IN\_PROP  -- define o contexto de leitura de Axiomas de Objetos 
\item RELATION -- define o contexto de inicio da leitura de Relaï¿½ï¿½o de Objetos 
\item RELATION\_BEG\_END -- define o contexto de inicio  da leitura do primeiro e segundo objectos na Relaï¿½ï¿½o de Objetos 



\vspace{1cm}
\item IN\_DATA -- define o contexto de leitura de Axiomas de Dados
\item DATA -- define o contexto do inï¿½cio da leitura dos  Dados
\item DATA\_BEG\_END -- define o contexto de inicio  da leitura da classe envolvida no Axioma de Dados 
\item VALUE -- define o contexto de inicio  da leitura do datatype envolvido no Axioma de Dados 

\vspace{1cm}

\item IN\_CLASS -- define o contexto de leitura de Axiomas de Classes
\item CLASS\_BEG\_END -- define o contexto de inicio  da leitura da primeira e segunda classes na Relaï¿½ï¿½o de Classes 
\end{itemize}

\subsection{Expressï¿½es Regulares e acï¿½ï¿½es resultantes}
\label{1er}
Definidas as start conditions, resta-nos explicitar todas as expressï¿½es regulares, incluindo aquelas que dï¿½o inï¿½cio ï¿½ comutaï¿½ï¿½o entre contextos do flex.
\begin{lstlisting}
[^<> ]*<{DAT_PROP_AXIOM}> { BEGIN IN_DATA; }
[^<> ]*<{OBJ_PROP_AXIOM}> { BEGIN IN_PROP; }
[^<> ]*<{CLA_PROP_AXIOM}> { BEGIN IN_CLASS; }

<IN_CLASS>[^<>]*<Class[ \t\n]*IRI=\" {BEGIN CLASS_BEG_END;}
<IN_CLASS><\/{CLA_PROP_AXIOM} {BEGIN INITIAL;}
<IN_CLASS>.|\n {;}

<CLASS_BEG_END>[^">]+/\" {
if ( class_subclass == NULL ){
  class_subclass = strdup(yytext);
}
else{
  class_class = strdup(yytext);
  print_class();
} 
}

<CLASS_BEG_END>\/> { BEGIN IN_CLASS;  }
<CLASS_BEG_END>.|\n {;}

<DATA>[^">]+/\" {data=strdup(yytext);} 
<DATA>\/> {BEGIN IN_DATA;}
<DATA>.|\n {;}

<IN_DATA>[^<>]*<DataProperty[ \t\n]*IRI=\" { BEGIN DATA;}
<IN_DATA>[^<>]*<Class[ \t\n]*IRI=\" { BEGIN DATA_BEG_END;}
<IN_DATA>[^<>]*<Datatype[ \t\n]*abbreviatedIRI=\" {  BEGIN VALUE;}
<IN_DATA><\/{DAT_PROP_AXIOM} {BEGIN INITIAL;}
<IN_DATA>.|\n {;}

<VALUE>[^"<>]+/\" { value = strdup(yytext); print_data(); }
<VALUE>\/> {BEGIN IN_DATA;}
<VALUE>.|\n {;}

<DATA_BEG_END>[^">]+/\" { class = strdup(yytext); }
<DATA_BEG_END>\/> {BEGIN IN_DATA;}
<DATA_BEG_END>.|\n {;}

<IN_PROP>[^<>]*<ObjectProperty[ \t\n]*IRI=\" { BEGIN RELATION;  }
<IN_PROP>[^<>]*<Class[ \t\n]*IRI=\" {  BEGIN RELATION_BEG_END;}
<IN_PROP><\/{OBJ_PROP_AXIOM} { BEGIN INITIAL;}
<IN_PROP>.|\n {;}

<RELATION>[^"<>]+/\" { relation=strdup(yytext);} 
<RELATION>\/> { BEGIN IN_PROP;}
<RELATION>.|\n {;}

<RELATION_BEG_END>[^"<>]+/\" {
if ( begin == NULL ){
  begin = strdup(yytext);
}
else{
  end = strdup(yytext);
  print_prop();
} 
}

<RELATION_BEG_END>\/> { BEGIN IN_PROP;}
<RELATION_BEG_END>.|\n { ;}

<INITIAL>.|\n {;}
\end{lstlisting}


\section{Codificaï¿½ï¿½o e Testes}
\subsection{Estruturas de Dados e bibliotecas utilizadas}
Como pode verificar, nï¿½o existem estruturas de dados complexas para a resoluï¿½ï¿½o deste problema, sendo que sï¿½o apenas utilizadas strings para guardar temporariamente os valores dos dados em relaï¿½ï¿½o. De seguida explicitam-se todas as variï¿½veis e bilbliotecas utilizadas:
\begin{lstlisting}
%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

  char* relation;
  char* begin;
  char* end;
  char* data;
  char* class;
  char* value;
  char* class_class;
  char* class_subclass;

  void print_prop();
  void print_data();
  void print_class();
  %}

  \end{lstlisting}

  \subsection{Mï¿½todos Adicionais}
  Como poderï¿½ constatar na seï¿½ï¿½o \ref{1er} existem 3 mï¿½todos adicionais invocados no final da leitura completa dos axiomas de objectos, classes e dados, sendo eles de seguida explicitados:

  \begin{lstlisting}
  void print_class(){
    printf("\"%s\" [shape = box, style=rounded, fontsize=12 fontname=helvetica];\n", class_subclass);
    printf("\"%s\" [shape = box, style=rounded, fontsize=12 fontname=helvetica];\n", class_class);
    printf("\"%s\" -> \"%s\" [ label = \"SubClassOf\" , fontsize=8 , fontcolor=\"blue\", color=\"blue\" ]\n", class_subclass, class_class );
    class_subclass=NULL;
    class_class=NULL;
  }

void print_data(){
  printf("\"%s\" [shape = box, style=rounded, fontsize=12 fontname=helvetica];\n", class);
  printf("\"%s\" [shape = box, style=filled,color=\"red\", fontsize=12 fontname=helvetica];\n", value);
  printf("\"%s\" -> \"%s\" [ label = \"%s\" ]\n", class, value, data );
  class=NULL;
  value=NULL;
  data=NULL;
}

void print_prop(){
  printf("\"%s\" [shape = box, style=rounded, fontsize=12 fontname=helvetica];\n", begin);
  printf("\"%s\" -> \"%s\" [ label = \"%s\" ]\n", begin, end, relation );
  begin=NULL;
  relation=NULL;
  end=NULL;
}
\end{lstlisting}
Os mï¿½todos por si sï¿½ sï¿½o elucidativos, sendo que a impressï¿½o ï¿½ realizada conforme a linguagem Dotty.

\subsection{Main}
Dada a simplicidade das estruturas de dados, o mï¿½todo main ï¿½ tambï¿½m bastante simples, de seguida explicitado:
\begin{lstlisting}
int main(int argc, char** argv){
  graph_print();
  yylex();
  printf("}\n");
  return (0);
}
\end{lstlisting}
O cï¿½digo completo da ferramenta ï¿½ passï¿½vel de consulta na seï¿½ï¿½o \ref{completo1a} na pï¿½gina \pageref{completo1a}.

\section{Testes realizados e Resultados}
Foi realizado um script da shell com vista a facilmente ilustrar as funcionalidades da ferramenta, sendo que essas mesma script lï¿½ o ficheiro exemplo test1.xml , criando o ficheiro ex1.gv e, a partir deste o ficheiro ex1.png, demonstrado na figura \ref{fig:ex1}.
\subsection{Shell Script}
\begin{lstlisting}
#!bin/sh

echo "/*
********************************************************************************
*Copyright(C) 2016 Filipe Oliveira, Universidade do Minho
*   All Rights Reserved.
*
********************************************************************************
*   Content : simple tool 1a) functionality script 
*
*
********************************************************************************/"

make clean
flex owl_graph.l
make 
./owl_graph < test1.xml > ex1.gv
dot ex1.gv -Tpng > ex1.png
echo "##########################"
echo ">>>>>>>> ex1 in ex1.png"
echo "         opening file"
echo "##########################"
open ex1.png
echo "done"
\end{lstlisting}

\subsection{Ficheiro Exemplo de input no formato OWL}
\begin{lstlisting}
<ObjectPropertyDomain>
<ObjectProperty IRI="#receives"/>
<Class IRI="#Laundry"/>
</ObjectPropertyDomain>
<ObjectPropertyRange>
<Annotation>
<AnnotationProperty abbreviatedIRI="owl:backwardCompatibleWith"/>
<IRI>#Laundry</IRI>
</Annotation>
<ObjectProperty IRI="#receives"/>
<Class IRI="#Order"/>
</ObjectPropertyRange>

<ObjectPropertyDomain>
<ObjectProperty IRI="#works"/>
<Class IRI="#Worker"/>
</ObjectPropertyDomain>
<ObjectPropertyRange>
<Annotation>
<AnnotationProperty abbreviatedIRI="owl:backwardCompatibleWith"/>
<IRI>#Worker</IRI>
</Annotation>
<ObjectProperty IRI="#works"/>
<Class IRI="#Laundry"/>
</ObjectPropertyRange>


<ObjectPropertyDomain>
<ObjectProperty IRI="#owns"/>
<Class IRI="#Client"/>
</ObjectPropertyDomain>
<ObjectPropertyRange>
<Annotation>
<AnnotationProperty abbreviatedIRI="owl:backwardCompatibleWith"/>
<IRI>#Client</IRI>
</Annotation>
<ObjectProperty IRI="#owns"/>
<Class IRI="#Order"/>
</ObjectPropertyRange>

<SubClassOf>
<Class IRI="#Laundry"/>
<Class IRI="#Stores"/>
</SubClassOf>
<SubClassOf>
<Class IRI="#Owner"/>
<Class IRI="#Person"/>
</SubClassOf>

<DataPropertyDomain>
<DataProperty IRI="#material"/>
<Class IRI="#Type"/>
</DataPropertyDomain>
<DataPropertyRange>
<DataProperty IRI="#material"/>
<Datatype abbreviatedIRI="xsd:string"/>
</DataPropertyRange>

<DataPropertyDomain>
<DataProperty IRI="#orderid"/>
<Class IRI="#Order"/>
</DataPropertyDomain>
<DataPropertyRange>
<DataProperty IRI="#orderid"/>
<Datatype abbreviatedIRI="xsd:string"/>
</DataPropertyRange>
<SubClassOf>
<Class IRI="#Client"/>
<Class IRI="#Person"/>
</SubClassOf>
<SubClassOf>
<Class IRI="#Worker"/>
<Class IRI="#Person"/>
</SubClassOf>

\end{lstlisting}


\subsection{Grafo exemplo resultante}
\begin{figure}[H]
\centering
\includegraphics[width=0.5\columnwidth]{PNG/ex1}
\caption{Grafo exemplo criado com as relaï¿½ï¿½es entre classes a partir da anï¿½lise do ficheiro test1.xml }
\label{fig:ex1}
\end{figure}




\chapter{Normalizador de ficheiros BibTeX}
\label{normalizador}


\section{Concepï¿½ï¿½o/desenho da Resoluï¿½ï¿½o}
Tal como descrito anteriormente o problema serï¿½ resolvido com recurso ï¿½ ferramenta Flex. 
Pretendemos entï¿½o analisar documentos BibTeX e:

\begin {itemize}
\item fazer a contagem das categorias(phDThesis, Misc, InProceeding, etc.) que ocorrem no documento, produzindo um documento em formato HTML com o nome das categorias encontradas e respectivas contagens;
\item Desenvolva uma ferramenta de normalizaï¿½ï¿½o (sempre que um campo estï¿½ entre aspas, trocar para chavetas e escrever o nome dos autores no formato "N. Apelido"), fazendo ainda uma ferramenta de pretty-printing que indente corretamente cada campo, escreva um autor por linha e colocando sempre no inï¿½cio os campos autor e tï¿½tulo.
\item Construir um Grafo que mostre, para um dado autor (escolhido pelo utilizador) todos os autores que publicam
normalmente com o autor em causa, recorrendo uma vez mais ï¿½ linguagem Dot do GraphViz2.
\end{itemize}
Para foram produzidos 3 ficheiros (bib\_norm\_1.l, bib\_norm\_2.l, bib\_norm\_3.l), um para cada alï¿½nea por forma a tornar de mais fï¿½cil compreensï¿½o o papel de cada expressï¿½o regular, start condition, ou estrutura de dados na soluï¿½ï¿½o geral. Facilmente se combinam os 3 ficheiros em 1, mas dado o propï¿½sito acadï¿½mico da ferramenta julgo ser fulcral a compreensï¿½o do anteriormente descrito em cada ficheiro e alï¿½nea do problema.

\section{alï¿½nea a) ficheiro bib\_norm\_1.l }
\subsection{Padrï¿½es de frases a encontrar, atravï¿½s de ER}
Podemos considerar que no contexto do problema apresentado temos interesse apenas na contagem das categorias, que serï¿½o facilmente encontradas com base nas seguintes definiï¿½ï¿½es de expressï¿½es regulares a serem utilizadas no Flex:

\begin{lstlisting}
LETRA [A-Za-z]
CATEG \@{LETRA}+\{
LETRA_NUM [0-9A-Za-z]
ID ({LETRA_NUM}|:)+
\end{lstlisting}


\subsubsection{Expressï¿½es Regulares e acï¿½ï¿½es resultantes}

Resta-nos explicitar todas as expressï¿½es regulares e respectivas acï¿½ï¿½es resultantes:

\begin{lstlisting}
%%
{CATEG}/[^=]*,      {
  yytext++; yytext[yyleng-2]='\0';
  char* key = g_ascii_strdown (yytext, yyleng-2);
  if ( g_hash_table_contains ( table ,(void*) key ) ){
    int value;
    value = GPOINTER_TO_INT( g_hash_table_lookup ( table,(void*) key));
    value++;
    g_hash_table_replace (  table, (void*) key,GINT_TO_POINTER(value) );
  }
  else {
    int value = 1;
    gboolean add_result = g_hash_table_insert (  table, (void*) key,  GINT_TO_POINTER(value) );
  }
                    }
.|\n|\t { ; }
%%
\end{lstlisting}


\subsection{Codificaï¿½ï¿½o }
\subsubsection{Estruturas de Dados e bibliotecas utilizadas}
Como pode verificar foi necessï¿½rio recorrer a  estruturas de dados complexas para a resoluï¿½ï¿½o deste problema, nomeadamente hash tables. Ora, segundo o conselho do professor Josï¿½ Joï¿½o, foi reutilizado cï¿½digo da biblioteca da GLib, biblioteca essa extremamente otimizada.
De seguida explicitam-se todas as variï¿½veis e bibliotecas utilizadas:
\begin{lstlisting}
%{
  /*
   ********************************************************************************
   *   Copyright(C) 2016 Filipe Oliveira, Universidade do Minho
   *   All Rights Reserved.
   *
   ********************************************************************************
   *   Content : Simple bibtex category counter (phDThesis, Misc, InProceeding,
   *             etc.), that occur in a document
   ********************************************************************************/

#include <stdio.h>
#include <glib.h>
#include <stdlib.h>
#include <string.h>

  //HashTable
  GHashTable *table; 

  %}
  \end{lstlisting}

  \subsubsection{Mï¿½todos Adicionais}
  Como poderï¿½ constatar na seï¿½ï¿½o \ref{1er} existe 1 mï¿½todo adicional invocado no final da leitura ficheiro, tendo por funï¿½ï¿½o imprimir o par ( chave -- valor ) num formato de lista HTML, sendo a chave a categoria BibTeX e o valor o nï¿½mero de ocorrï¿½ncias da mesma no ficheiro:

  \begin{lstlisting}
  static void print_key_value(gpointer key, gpointer value, gpointer userdata){
    int val = (int) value;
    char* ke = (char*) key;
    printf("<li>%s : %d</li>\n", ke, val);
  }
\end{lstlisting}

\subsubsection{Main}
Dada a simplicidade do analisador, o mï¿½todo main ï¿½ tambï¿½m bastante simples, apenas imprimindo as tags HTML e inicializando a hashtable. Passaremos de seguida a explicitï¿½-lo:
\begin{lstlisting}

int main(){
  table = g_hash_table_new(g_str_hash, g_str_equal);
  yylex();
  printf("<!DOCTYPE html>\n<html>\n<body>\n<ul>\n");
  g_hash_table_foreach(table,print_key_value, NULL );
  printf("</ul>\n</body>\n</html>\n");
  return (0);
}
\end{lstlisting}
O cï¿½digo completo da ferramenta ï¿½ passï¿½vel de consulta na seï¿½ï¿½o \ref{completo2a} na pï¿½gina \pageref{completo2a}.



%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%


\section{alï¿½nea b) ficheiro bib\_norm\_2.l }
\subsection{Padrï¿½es de frases a encontrar, atravï¿½s de ER}
Podemos considerar que no contexto do problema apresentado temos interesse em todos os campos de cada entrada, sendo que teremos de tratar especialmente os campos author e title. Tal tarefa ï¿½ facilitada com base nas seguintes definiï¿½ï¿½es de expressï¿½es regulares a serem utilizadas no Flex:

\begin{lstlisting}
LETRA [A-Za-z]
LETRA_NUM [0-9A-Za-z]
NUM [0-9]
CATEG \@{LETRA}+\{
FIELD_ID ^[^,}"][^=]*=[ \t]*
FIELD_BREAK [^=]*[ \t\n]*(\"|\})
FIELD_BREAK_NUM [^=\}]*\}?
FIELD_START [\{\"]
AUTHOR_ID ^[ \t]*[Aa][Uu][Tt][Hh][Oo][Rr][ \t]*=[ \t]*
TITLE_ID ^[ \t]*[Tt][Ii][Tt][Ll][Ee][ \t]*=[ \t]*
AUTHOR_SEP [ \t]and[ \t]
AUTHOR_BREAK [^=]+(\"|\})
\end{lstlisting}


\subsubsection{Comutaï¿½ï¿½o de contextos em Flex atravï¿½s de start conditions}
Por forma a realizar a correta anï¿½lise dos padrï¿½es de texto foi necessï¿½rio adicionar start conditions ï¿½s regras das expressï¿½es regulares. Deste modo, apresenta-se a lista de todas as start conditions utilizadas:

\begin{lstlisting}
%x INSIDE IN_AUTHOR IN_FIELD_TXT IN_FIELD_NUM AUTHOR_DIV START_AUTHOR
\end{itemize}

\subsubsection{Expressï¿½es Regulares e acï¿½ï¿½es resultantes}
\label{2ber}
Definidas as start conditions, resta-nos explicitar todas as expressï¿½es regulares, incluindo aquelas que dï¿½o inï¿½cio ï¿½ comutaï¿½ï¿½o entre contextos do flex.
\begin{lstlisting}
%%

{CATEG}[^=]*,            {
  printf("%s\n",yytext);
  BEGIN INSIDE;
                         }

<INSIDE>{TITLE_ID}{FIELD_START}  {   
  yytext[yyleng-2]='\0';
  title_key = strdup ( yytext );
  title_key = g_strchomp ( title_key );
  title_key = g_strchug ( title_key );
  field_id = strdup(title_key);
  BEGIN IN_FIELD_TXT;}

  <INSIDE>{AUTHOR_ID}{FIELD_START}  {   
    yytext[yyleng-2]='\0';
    author_key = strdup ( yytext );
    author_key = g_strchomp ( author_key );
    author_key = g_strchug ( author_key );
    BEGIN START_AUTHOR;
  }

<INSIDE>{FIELD_ID}/{LETRA_NUM}  {   
  yytext[yyleng-1]='\0';
  field_id = strdup ( yytext );
  field_id = g_strchomp ( field_id );
  field_id = g_strchug ( field_id );
  BEGIN IN_FIELD_NUM; }

  <INSIDE>{FIELD_ID}{FIELD_START}  {   
    yytext[yyleng-2]='\0';
    field_id = strdup ( yytext );
    field_id = g_strchomp ( field_id );
    field_id = g_strchug ( field_id );
    BEGIN IN_FIELD_TXT;
  }

<INSIDE>[ \n\t]*, { BEGIN INSIDE; }
<INSIDE>[ \n\t]*\} { BEGIN INITIAL; }
<INSIDE>.|\n { BEGIN INSIDE;}

<START_AUTHOR>.          {
  author_initial = (char*) malloc ( 4* sizeof(char));
  author_initial[0] = yytext[0];
  author_initial[1] = '.';
  author_initial[2]=' ';
  author_initial[3]='\0';
  BEGIN IN_AUTHOR;
}

<IN_AUTHOR>[^= \n\t]*/[ ]and[ ]     {   
  author_lastname = strdup ( yytext );
  author_lastname = g_strchomp ( author_lastname );
  author_lastname = g_strchug ( author_lastname );
  char *initial_plus_lastname;
  int size = strlen(author_lastname);
  size += strlen( author_initial) + 1;
  initial_plus_lastname = (char*) malloc ( size * sizeof(char));
  strcpy(initial_plus_lastname, author_initial);
  strcat(initial_plus_lastname, author_lastname);
  g_hash_table_insert (  authors_table, (void*) initial_plus_lastname,   GINT_TO_POINTER (0) );
  BEGIN AUTHOR_DIV;
}

<IN_AUTHOR>[^= \n\t]*[ \t]?(\"|\})/,    { 
yytext[yyleng-1]='\0';
author_lastname = strdup ( yytext );
author_lastname = g_strchomp ( author_lastname );
author_lastname = g_strchug ( author_lastname );
char *initial_plus_lastname;
int size = strlen(author_lastname);
size += strlen( author_initial) + 1;
initial_plus_lastname = (char*) malloc ( size * sizeof(char));
strcpy(initial_plus_lastname, author_initial);
strcat(initial_plus_lastname, author_lastname);
g_hash_table_insert (  authors_table, (void*) initial_plus_lastname,   GINT_TO_POINTER (0) );
BEGIN AUTHOR_DIV;
}

<IN_AUTHOR>.              { ; }

<AUTHOR_DIV>,             { BEGIN INSIDE; }

<AUTHOR_DIV>[ ]and[ ]     { BEGIN START_AUTHOR; }


<IN_FIELD_NUM>{FIELD_BREAK_NUM}[ \n\t\r]*\} {
  yytext[yyleng-1]='\0';
  field = strdup(yytext);
  field = g_strchomp ( field );
  field = g_strchug ( field );
  g_hash_table_insert (  num_fields_table, (void*) field_id,  (void*) field );
  pretty_print();
  BEGIN INITIAL;
}

<IN_FIELD_NUM>{FIELD_BREAK_NUM}[ \n\t\r]*(#[^,=]*)?, {
  yytext[yyleng-1]='\0';
  field = strdup(yytext);
  field = g_strchomp ( field );
  field = g_strchug ( field );
  g_hash_table_insert (  num_fields_table, (void*) field_id,  (void*) field );
  BEGIN INSIDE;
}

<IN_FIELD_TXT>{FIELD_BREAK}[ \n\t\r]*\} {
  yytext[yyleng-2]='\0';
  field = strdup(yytext);
  field = g_strchomp ( field );
  field = g_strchug ( field );
  g_hash_table_insert (  txt_fields_table, (void*) field_id,  (void*) field );
  BEGIN INITIAL;
  pretty_print();
}

<IN_FIELD_TXT>{FIELD_BREAK}[ \n\t\r]*(#[^,=]*)?, {
  yytext[yyleng-2]='\0';
  field = strdup(yytext);
  field = g_strchomp ( field );
  field = g_strchug ( field );
  g_hash_table_insert (  txt_fields_table, (void*) field_id,  (void*) field );
  BEGIN INSIDE;
}

<IN_FIELD_TXT>.|\n {;}
<IN_FIELD_NUM>.|\n {;}

{CATEG}[^\n]*\}             { printf("%s\n",yytext);}

<INITIAL>.|\n {;}

%%
\end{lstlisting}



\subsection{Codificaï¿½ï¿½o }
\subsubsection{Estruturas de Dados e bibliotecas utilizadas}
Como pode verificar foi necessï¿½rio recorrer a  estruturas de dados complexas para a resoluï¿½ï¿½o deste problema, nomeadamente hash tables. Ora, segundo o conselho do professor Josï¿½ Joï¿½o, foi reutilizado cï¿½digo da biblioteca da GLib, biblioteca essa extremamente otimizada.
De seguida explicitam-se todas as variï¿½veis e bibliotecas utilizadas:
\begin{lstlisting}
%{
  /*
   ********************************************************************************
   *   Copyright(C) 2016 Filipe Oliveira, Universidade do Minho
   *   All Rights Reserved.
   *
   ********************************************************************************
   *   Content : 2b) bibtex file normalizer and pretty-printer
   ********************************************************************************/

#include <stdio.h>
#include <glib.h>
#include <stdlib.h>
#include <string.h>

  //HashTable
  GHashTable *txt_fields_table; 
  GHashTable *num_fields_table; 
  GHashTable *authors_table; 
  char* field_id;
  char* field;
  char* author_id = "author";
  char* title_id = "title";
  char* author_key;
  char* title_key;
  char* author_initial;
  char* author_lastname;

  //function sig
  void pretty_print();

  %}
  \end{lstlisting}

  \subsubsection{Mï¿½todos Adicionais}
  Como poderï¿½ constatar na seï¿½ï¿½o \ref{1er} existe 1 mï¿½todos adicional invocado no final da leitura de cada entrada do ficheiro, tendo por funï¿½ï¿½o imprimir o registo num formato normalizado:

  \begin{lstlisting}
  %{
    void pretty_print(){
      int field_num = 0;
      char* current_value;

      GHashTableIter iter;
      gpointer key, value;

      if( title_key != NULL ){
        current_value =  g_hash_table_lookup ( txt_fields_table,(void*) title_key);
        g_hash_table_remove ( txt_fields_table, (void*) title_key);
        printf("\t%s {%s}", title_key, current_value);
        field_num++;
      }

      if ( author_key != NULL ){
        if(field_num > 0){ printf(",\n"); }
        printf("\t%s {", author_key);
        int number_authors = g_hash_table_size ( authors_table );
        int author_num = 1;
        g_hash_table_iter_init (&iter, authors_table );
        while (g_hash_table_iter_next (&iter, &key, &value)){
          if(author_num > 1 ){ printf("\n\t\tand "); }
          char* name = (char*) key;
          printf("%s", name);
          g_hash_table_iter_remove (&iter);
          author_num++;
        } 
        printf("}");
        field_num++;
      }

      int size = g_hash_table_size ( txt_fields_table );
      size += g_hash_table_size ( num_fields_table );
      g_hash_table_iter_init (&iter, txt_fields_table );
      while (g_hash_table_iter_next (&iter, &key, &value)){
        if(field_num > 0 ){ printf(",\n"); }
        char* val = (char*) value;
        char* ke = (char*) key;
        printf("\t%s {%s}", ke, val);
        g_hash_table_iter_remove (&iter);
      } 

      g_hash_table_iter_init (&iter, num_fields_table );
      while (g_hash_table_iter_next (&iter, &key, &value)){
        if(field_num > 0 ){ printf(",\n"); }
        char* val = (char*) value;
        char* ke = (char*) key;
        printf("\t%s %s", ke, val);
        g_hash_table_iter_remove (&iter);
      }
      printf("\n}\n\n");
    }
    \end{lstlisting}

    \subsubsection{Main}
    O mï¿½todo main ï¿½ tambï¿½m bastante simples, apenas inicializando as hashtables. Passaremos de seguida a explicitï¿½-lo:
      \begin{lstlisting}
    int main(){
      txt_fields_table = g_hash_table_new(g_str_hash, g_str_equal);
      num_fields_table = g_hash_table_new(g_str_hash, g_str_equal);
      authors_table = g_hash_table_new(g_str_hash, g_str_equal);
      yylex();
      return (0);
    }
    \end{lstlisting}
    O cï¿½digo completo da ferramenta ï¿½ passï¿½vel de consulta na seï¿½ï¿½o \ref{completo2b} na pï¿½gina \pageref{completo2a}.


      %%%%%%%%%%%%%%%%%
      %%%%%%%%%%%%%%%%%
      %%%%%%%%%%%%%%%%%


      \section{alï¿½nea c) ficheiro bib\_norm\_3.l }
    \subsection{Padrï¿½es de frases a encontrar, atravï¿½s de ER}
    Podemos considerar que no contexto do problema apresentado temos interesse no campo author de cada  entrada, ou seja, podemos reaproveitar grande parte do trabalho desenvolvido na alï¿½nea anterior. Tal tarefa ï¿½ facilitada com base nas seguintes definiï¿½ï¿½es de expressï¿½es regulares a serem utilizadas no Flex:

      \begin{lstlisting}
    LETRA [A-Za-z]
      LETRA_NUM [0-9A-Za-z]
      NUM [0-9]
      CATEG \@{LETRA}+\{
      FIELD_START [\{\"]
      AUTHOR_ID [ \t]*[Aa][Uu][Tt][Hh][Oo][Rr][ \t]*=[ \t]*
      AUTHOR_SEP [ \t]and[ \t]
      AUTHOR_BREAK [^=]+(\"|\})
      \end{lstlisting}


    \subsubsection{Comutaï¿½ï¿½o de contextos em Flex atravï¿½s de start conditions}
    Por forma a realizar a correta anï¿½lise dos padrï¿½es de texto foi necessï¿½rio adicionar start conditions ï¿½s regras das expressï¿½es regulares. Deste modo, apresenta-se a lista de todas as start conditions utilizadas:

      \begin{lstlisting}
    %x INSIDE IN_AUTHOR IN_FIELD_TXT IN_FIELD_NUM AUTHOR_DIV START_AUTHOR
      \end{itemize}

    \subsubsection{Expressï¿½es Regulares e acï¿½ï¿½es resultantes}
    \label{2cer}
    Definidas as start conditions, resta-nos explicitar todas as expressï¿½es regulares, incluindo aquelas que dï¿½o inï¿½cio ï¿½ comutaï¿½ï¿½o entre contextos do flex.
      \begin{lstlisting}
    %%

    {CATEG}[^=]*,           { BEGIN INSIDE; }

    <INSIDE>{AUTHOR_ID}{FIELD_START}  {   
      yytext[yyleng-2]='\0';
      author_key = strdup ( yytext );
      author_key = g_strchomp ( author_key );
      author_key = g_strchug ( author_key );
      BEGIN START_AUTHOR;
    }

    <INSIDE>[ \n\t]*,       { BEGIN INSIDE; }
    <INSIDE>[ \n\t]*\}      { BEGIN INITIAL; }

    <INSIDE>.|\n              { BEGIN INSIDE;}

    <START_AUTHOR>.           {
      author_initial = (char*) malloc ( 4* sizeof(char));
      author_initial[0] = yytext[0];
      author_initial[1] = '.';
      author_initial[2]=' ';
      author_initial[3]='\0';
      BEGIN IN_AUTHOR;
    }

    <IN_AUTHOR>[^= \n\t]*/[ ]and[ ]     {   
      author_lastname = strdup ( yytext );
      author_lastname = g_strchomp ( author_lastname );
      author_lastname = g_strchug ( author_lastname );
      char *initial_plus_lastname;
      int size = strlen(author_lastname);
      size += strlen( author_initial) + 1;
      initial_plus_lastname = (char*) malloc ( size * sizeof(char));
      strcpy(initial_plus_lastname, author_initial);
      strcat(initial_plus_lastname, author_lastname);
      g_hash_table_insert (  authors_table, (void*) initial_plus_lastname,   GINT_TO_POINTER (0) );
      BEGIN AUTHOR_DIV;
    }

    <IN_AUTHOR>[^= \n\t]*[ \t]?(\"|\})/,    { 
      yytext[yyleng-1]='\0';
    author_lastname = strdup ( yytext );
    author_lastname = g_strchomp ( author_lastname );
    author_lastname = g_strchug ( author_lastname );
    char *initial_plus_lastname;
    int size = strlen(author_lastname);
    size += strlen( author_initial) + 1;
    initial_plus_lastname = (char*) malloc ( size * sizeof(char));
    strcpy(initial_plus_lastname, author_initial);
    strcat(initial_plus_lastname, author_lastname);
    g_hash_table_insert (  authors_table, (void*) initial_plus_lastname,   GINT_TO_POINTER (1) );
    BEGIN AUTHOR_DIV;
  }

  <IN_AUTHOR>.              { ; }
  <AUTHOR_DIV>,             { check_authors(); BEGIN INSIDE; }
  <AUTHOR_DIV>[ ]and[ ]             { BEGIN START_AUTHOR; }
  <INITIAL>.|\n {;}

  %%
    \end{lstlisting}



  \subsection{Codificaï¿½ï¿½o }
  \subsubsection{Estruturas de Dados e bibliotecas utilizadas}
  Como pode verificar foi necessï¿½rio recorrer a  estruturas de dados complexas para a resoluï¿½ï¿½o deste problema, nomeadamente hash tables. Ora, segundo o conselho do professor Josï¿½ Joï¿½o, foi reutilizado cï¿½digo da biblioteca da GLib, biblioteca essa extremamente otimizada.
    De seguida explicitam-se todas as variï¿½veis e bibliotecas utilizadas:
    \begin{lstlisting}
  %{

    /*
     ********************************************************************************
     *   Copyright(C) 2016 Filipe Oliveira, Universidade do Minho
     *   All Rights Reserved.
     *
     ********************************************************************************
     *   Content : 2c) bibtex co-authoring graph builder for a given normalized.
     *             author name.
     ********************************************************************************/

#include <stdio.h>
#include <glib.h>
#include <stdlib.h>
#include <string.h>

    //HashTable
    GHashTable *authors_table; 
    GHashTable *coauthors_table; 
    char* author_key;
    char* author_initial;
    char* author_lastname;
    char* author_name; 
    //function sig
    void print_graph();
    void check_authors();

    %}
    \end{lstlisting}

    \subsubsection{Mï¿½todos Adicionais}
    Como poderï¿½ constatar na seï¿½ï¿½o \ref{1er} existem 2 mï¿½todos adicionais. Um (check\_authors()) invocado no final da leitura de cada entrada do ficheiro, tendo por funï¿½ï¿½o verificar se o autor em causa estï¿½ referenciado no artigo e se sim, calcular o mapa dos seus co-autores. O outro mï¿½todo (graph\_print()) ï¿½ invocado aquando da impressï¿½o do grafo no format Dot:

      \begin{lstlisting}

    void check_authors(){
      if ( g_hash_table_contains ( authors_table ,(void*) author_name ) ){
        g_hash_table_remove( authors_table, author_name );
        GHashTableIter iter;
        gpointer key, value;
        g_hash_table_iter_init (&iter, authors_table );
        while (g_hash_table_iter_next (&iter, &key, &value)){
          char* coauthor_name = (char*) key;
          int number_entries = 0;
          if ( g_hash_table_contains ( coauthors_table ,key ) ){
            number_entries = GPOINTER_TO_INT( g_hash_table_lookup ( coauthors_table , key));
            number_entries++;
            g_hash_table_replace (  coauthors_table, key, GINT_TO_POINTER( number_entries ) );
          }
          else{
            number_entries++;
            g_hash_table_insert (  coauthors_table, key,   GINT_TO_POINTER (number_entries) );
          }
        }
      }
      g_hash_table_remove_all( authors_table );
    }

    void graph_print(){

      GHashTableIter iter;
      gpointer key, value;
      g_hash_table_iter_init (&iter, coauthors_table );

      printf( "digraph pl_2_2_a {\n//title\nlabelloc=\"t\";\nlabel=\"%s Document collaboration and co-authoring diagram\";rankdir=TB;\nresolution=300;size=\"8,5\";", author_name);
      printf("\"%s\"[shape = box,style=filled,color=\"red\", style=rounded, fontsize=16 fontname=helvetica];\n", author_name);
      printf("node [shape = box, style=rounded, fontsize=12 fontname=helvetica]");
      while (g_hash_table_iter_next (&iter, &key, &value))
      {
        char* coauthor_name = g_str_to_ascii ((char*) key, "C");
        int number_entries = GPOINTER_TO_INT( value );
        printf("\"%s\" -> \"%s\" [ label = \"%d\" ]\n", author_name, coauthor_name, number_entries );
      }
      printf("}\n");
    } 
    \end{lstlisting}

    \subsubsection{Main}
    O mï¿½todo main ï¿½ tambï¿½m bastante simples. Primeiramente  inicializa as hashtables, sendo que de seguida coloca na variï¿½vel author\_name o valor do author a procurar artigos com co-autores. Apï¿½s a leitura do ficheiro imprime  no formato da linguagem Dot o grafo de co-autorias. Passaremos de seguida a explicitï¿½-lo:
      \begin{lstlisting}
    int main(int argc, char** argv){
      authors_table = g_hash_table_new(g_str_hash, g_str_equal);
      coauthors_table = g_hash_table_new(g_str_hash, g_str_equal);
      author_name = strdup(argv[1]);
      yylex();
      graph_print();
      return (0);
    }
    \end{lstlisting}
    O cï¿½digo completo da ferramenta ï¿½ passï¿½vel de consulta na seï¿½ï¿½o \ref{completo2c} na pï¿½gina \pageref{completo2c}.



      %%%%%%%%%%%%%%%%%%%%%%%%%%%




      \section{Testes realizados e Resultados}
    Foi realizado um script da shell com vista a facilmente ilustrar as funcionalidades da ferramenta, sendo que essas mesma script lï¿½ o ficheiro exemplo lp.bib , criando os ficheiros ex2a.html, ex2b.bib e ex2c.gv. A partir do ficheiro ex2c.gv cria ainda o ficheiro ex2c.png, demonstrado na figura \ref{fig:ex2c}. 
      Na figura \ref{fig:ex2a} poderï¿½ ainda ver a pï¿½gina html exemplo resultante.

      \subsubsection{Shell Script}
    \begin{lstlisting}
#!bin/sh

    echo "/*
      ********************************************************************************
      *Copyright(C) 2016 Filipe Oliveira, Universidade do Minho
      *   All Rights Reserved.
      *
      ********************************************************************************
      *   Content : 2a) bibtex category counter (phDThesis, Misc, InProceeding,
        *             etc.), that occur in a document
      *           : 2b) bibtex file normalizer and pretty-printer
      *           : 2c) bibtex co-authoring graph builder for a given normalized 
      *             author name 
      ********************************************************************************/"

      make clean
      flex bib_norm_1.l
      make a1
      ./bib_norm_1 < lp.bib > ex2a.html
      echo "##########################"
      echo ">>>>>>>> ex2a in ex2a.html"
      echo "         opening file"
      echo "##########################"
      open ex2a.html

      make clean
      flex bib_norm_2.l
      make a2
      ./bib_norm_2 < lp.bib > ex2b.bib
      echo "##########################"
      echo ">>>>>>>> ex2b in ex2b.bib"
      echo "##########################"

      make clean
      flex bib_norm_3.l
      make a3
      ./bib_norm_3 "P. Henriques" < lp.bib > ex2c.gv
      dot ex2c.gv -Tpng > ex2c.png
      echo "##########################"
      echo ">>>>>>>> ex2c in ex2c.png"
      echo "         opening file"
      echo "##########################"
      open ex2c.png
      echo "done"
      \end{lstlisting}



    \subsubsection{Pï¿½gina HTML exemplo resultante da alï¿½nea 2a }
    \begin{figure}[H]
      \centering
      \includegraphics[width=0.5\columnwidth]{PNG/ex2a}
    \caption{Pï¿½gina HTML exemplo resultante da alï¿½nea 2a a partir da leitura do ficheiro lp.bib}
    \label{fig:ex2a}
    \end{figure}

    \subsubsection{Grafo exemplo resultante da alï¿½nea 2c}
    \begin{figure}[H]
      \centering
      \includegraphics[width=\columnwidth]{PNG/ex2c}
    \caption{Grafo exemplo criado com as relaï¿½ï¿½es de co-autoria do autor P.Henriques a partir da leitura do ficheiro lp.bib}
    \label{fig:ex2c}
    \end{figure}






    \chapter{Conclusï¿½o} \label{concl}

    Relativamente ao estado final do projecto acredito que foram cumpridos todos os requisitos, sendo que o segundo exercï¿½cio foi sem dï¿½vida o mais desafiante dada a enorme quantidade de dados e o tipo de dados em si a serem analisados. Reconhecer por si sï¿½ quais as sequï¿½ncias de caracteres  vï¿½lidas foi um desafio.\par Naturalmente que a partir da alï¿½nea 2.2.b a alï¿½nea 2.2.c foi de extrema facilidade, uma vez que todo o trabalho de anï¿½lise jï¿½ estava realizado. \par 
      Foi ainda tido em conta a possiblidade de recuperar de erros de leitura na alï¿½nea 2.2.b o que facilitou o input correct de dados e posterior tratamento.
      O recurso ï¿½ biblioteca Glib, recomendada pelo professor Josï¿½ Joï¿½o num aula laboratorial permitiu-me ambientar ainda mais com cï¿½digo desenvolvido por terceiros  e sua correcta anï¿½lise e integraï¿½ï¿½o nos meus projectos.\par 
      Faï¿½o um balanï¿½o positivo do trabalho prï¿½tico, pois, apesar de ser extremamente "time consuming" retirei muito conhecimento no que da anï¿½lise de dados e processamento de linguagens diz respeito.

      \appendix
      \chapter{Cï¿½digo do Programa da alï¿½nea 1a}
    \label{completo1a}
    \lstinputlisting{owl_graph.l} %input de um ficheiro

      \newpage
      \chapter{Cï¿½digo do Programa da alï¿½nea 2a}
    \label{completo2a}
    \lstinputlisting{bib_norm_1.l} %input de um ficheiro

      \newpage
      \chapter{Cï¿½digo do Programa da alï¿½nea 2b}
    \label{completo2b}
    \lstinputlisting{bib_norm_2.l} %input de um ficheiro


      \newpage
      \chapter{Cï¿½digo do Programa da alï¿½nea 3a}
    \label{completo2c}
    \lstinputlisting{bib_norm_3.l} %input de um ficheiro



      \end{document}



    \end{document} 
