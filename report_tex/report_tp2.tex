%
% Layout retirado de http://www.di.uminho.pt/~prh/curplc09.html#notas
%

\documentclass{report}
\usepackage[portuges]{babel}
\usepackage[latin1]{inputenc}

\usepackage{url}
\usepackage{listings}
\lstset{
keepspaces=true,  
tabsize=2,
basicstyle=\footnotesize,
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    breaklines=true,
    frame=tB,
    mathescape=true,
    escapeinside={(*@}{@*)}
}


\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=C,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{blue},
  stringstyle=\color{orange},
}


%%                                                       -*- LaTeX -*-
%% Language definition of Yacc/Bison for listings package
%%

%% Yacc
\lstdefinelanguage[]{Yacc}%
  {otherkeywords=%
    {\%left,
      \%nonassoc,\%prec,\%right,
      \%start,\%token,\%type,\%union,
      \%\%,\%\{,\%\},|,:,
      \$\$,\$1,\$2,\$3,\$4,\$5,\$6,\$7,\$8,\$9
    },%
    keywords={\%seeREADME},%
    morecomment=[n]{/*}{*/},%
    morestring=[b]{"},%
    sensitive=true
  }[keywords,comments,strings]%


%% Yacc: Bison

%% Listings does not support ``moreotherkeywords'', so we cannot
%% simply inherit.  To bad for code duplication.
\lstdefinelanguage[Bison]{Yacc}%
  {otherkeywords=%
    {\%binary,\%debug,\%default-prec,\%define,\%defines,\%destructor,
      \%dprec,\%error-verbose,\%expect,\%expect-rr,\%file-prefix,
      \%fixed-output-files,\%initial-action,\%glr-parser,
      \%language,\%left,
      \%lex-param,\%locations,\%merge,\%name-prefix,\%no-default-prec,
      \%no-lines,\%nonassoc,\%nondeterministic-parser,\%nterm,\%output,
      \%parse-param,\%prec,\%printer,\%pure-parser,\%right,\%skeleton,
      \%start,\%term,\%token,\%token-table,\%type,\%union,\%verbose,\%yacc,
      \%\%,\%\{,\%\},|,:,
      \$\$,\$1,\$2,\$3,\$4,\$5,\$6,\$7,\$8,\$9,
      @\$,@1,@2,@3,@4,@5,@6,@7,@8,@9
    },%
    keywords={\%seeREADME},%
    morecomment=[n]{/*}{*/},%
    morecomment=[s]{//},%
    morestring=[b]{"},%
    sensitive=true
  }[keywords,comments,strings]%

\lstdefinelanguage{Bison}[Bison]{Yacc}{}


\usepackage{fix-cm}

\usepackage{listings}






\usepackage{xspace}
\usepackage{graphicx}
\usepackage{float}

\parindent=0pt
\parskip=2pt

\setlength{\oddsidemargin}{-1cm}
\setlength{\textwidth}{18cm}
\setlength{\headsep}{-1cm}
\setlength{\textheight}{23cm}

\def\darius{\textsf{Darius}\xspace}
\def\java{\texttt{Java}\xspace}
\def\pe{\emph{Publicação Eletrónica}\xspace}


\title{Processamento de Linguagens (3º ano de Curso)\\ \textbf{Trabalho Prático N 2}\\ Relatório de Desenvolvimento}
\author{Filipe Costa Oliveira\\ a57816  }
\date{\today}

\begin{document}

\maketitle

\newpage

\tableofcontents

\chapter{Introdução} \label{intro}

O presente trabalho prático foca-se no desenvolvimento de  um compilador, que tem como fonte uma linguagem de alto nível (também esta desenvolvida especificamente para este trabalho prático) , gerando código para uma máquina de stack virtual. \par 
Um compilador comum divide o processo de tradução em várias fases. Para o propósito específico desta unidade curricular iremos focar-nos nas seguintes:
\begin{itemize}
\item 1ª Fase de tradução -- Análise Léxica, que agrupa sequências de caracteres em tokens. Recorreremos nesta fase à definição das expressões regulares que permitem definir os tokens.
\item 2ª Fase de tradução --  Reconhecimento(Parsing) da estrutura gramatical do programa, através do agrupamento dos tokens em produções. Recorreremos à definição de uma gramática independente de contexto por forma a definir as estruturas de programa válidas a reconhecer pelo parser. Denote que juntamente com o parsing é realizada a análise semântica, assim como a geração de código associando regras às produções anteriormente descritas.
\end{itemize} 
Começaremos portanto por definir uma linguagem de programação imperativa simples, que chamaremos Algebra. A Algebra permitirá:
\begin{itemize}
\item declarar e manusear variáveis atómicas do tipo inteiro, com os quais se podem realizar as habituais operações
aritméticas, relacionais e lógicas.
\item declarar e manusear variáveis estruturadas do tipo array (a 1 ou 2 dimensões) de inteiros, em relação aos quais  é apenas permitida a operação de indexação. Aos arrays de duas dimensões, por se tratar de uma linguagem algébrica, chamaremos matrizes, dada a fácil associação a este tipo de variável à sua definição análoga da álgebra linear.
\item efetuar instruções algorítmicas básicas como a atribuição de expressões a variáveis.
\item ler do standard input e escrever no standard output.
\item  efetuar instruções para controlo do fluxo de execução -- condicional e cíclica -- que possam ser aninhadas.
\item definir e invocar subprogramas sem parâmetros mas que possam retornar um resultado atómico.
\end{itemize} 

Na nossa linguagem de programação por questões de estruturação e percepção, teremos como premissa que as varíaveis deverão ser declaradas no início do programa, não podendo haver re-declarações, nem utilizações sem declaração prévia. Não será permitida a declaração e associação de um valor inteiro na mesma instrução. Achamos essa solução pouco elegante. Assim, todas as variáveis terão o valor zero após a declaração.\par 

Será desenvolvido portanto o compilador para a Algebra, com base na GIC criada acima e recurso ao Gerador Yacc/ Flex.
O compilador de Algebra irá gerar pseudo-código, Assembly da Máquina Virtual VM cuja documentação completa está disponibilizada em anexo.\par
Por forma a facilitar e validar o trabalho, à medida que as funcionalidades forem descritas serão apensados  exemplos ilustrativos. \par 
Por fim, serão apresentados um conjunto de testes mais complexos(programas-fonte diversos e respectivo código produzido), que tentam testar de uma forma mais alargadas as funcionalidades da Algebra, sendo estes:
\begin{itemize}
\item lidos 3 números, escrever o maior deles.
\item ler N (valor dado) números e calcular e imprimir o seu somatório.
\item contar e imprimir os números pares de uma sequência de N números dados.
\item ler e armazenar os elementos de um vetor de comprimento N, 
  imprimido os valores por ordem crescente após fazer a ordenação do array por trocas diretas.
  \item ler e armazenar os elementos de uma matriz NxM, calculando e imprimindo de seguida a média e máximo dessa matriz.
  \item  invocar e usar num programa  uma função.
  \end{itemize} 


\chapter{Concepção da Linguagem Algebra}
\label{concepcao}

\section{Concepção/desenho da Resolução}


Comecemos por descrever as funcionalidades da linguagem Algebra. Tal como descrito anteriormente a Algebra permitirá:
\begin{itemize}

\item declarar e manusear variáveis atómicas do tipo inteiro, com os quais se podem realizar as habituais operações
aritméticas, relacionais e lógicas.
\item declarar e manusear variáveis estruturadas do tipo array (a 1 ou 2 dimensões) de inteiros, em relação aos quais  é apenas permitida a operação de indexação. Aos arrays de duas dimensões, por se tratar de uma linguagem algébrica, chamaremos matrizes, dada a fácil associação a este tipo de variável à sua definição análoga da álgebra linear.
\item efetuar instruções algorítmicas básicas como a atribuição de expressões a variáveis.
\item ler do standard input e escrever no standard output.
\item  efetuar instruções para controlo do fluxo de execução -- condicional e cíclica -- que possam ser aninhadas.
\item definir e invocar subprogramas sem parâmetros mas que possam retornar um resultado atómico.

\end{itemize} 

\subsection{Uma introdução às variáveis}
Temos então que as variáveis poderão ser de 3 tipos: inteiros simples, arrays de inteiros, e matrizes de inteiros. Dessa premissa sabemos à partida que o código gerado para a nossa máquina virtual terá que suportar o tipo de variável inteiro. Sabemos ainda que os tipos de dados mais complexos (arrays e matrizes) apenas é permita a realização de operações de indexação. \par
Na nossa linguagem de programação por questões de estruturação e percepção, teremos como premissa que as variáveis deverão ser declaradas no início do programa, não podendo haver re-declarações, nem utilizações sem declaração prévia. Não será permitida a declaração e associação de um valor inteiro na mesma instrução(à lá C). Achamos essa solução pouco elegante. 
Assim, todas as variáveis terão o valor zero após a declaração.\par
Podemos então aceitar como exemplo as declarações do tipo:
\begin{lstlisting}
int a;
int auxiliar_1;
int array_1d[10];
int exemplo_2d[40,2];
\end{lstlisting}

Dado que toda a porção de código de alto nível julgamos essencial a possibilidade de existência de comentários. Atente no exemplo anterior agora com comentários que facilitam a percepção:
\begin{lstlisting}
// variaveis do tipo inteiro
int a;
int auxiliar_1;
// arrays de inteiros
int array_1d[10];
// matrizes
int exemplo_2d[40,2];
\end{lstlisting}

Tal como poderá confirmar pela última declaração do exemplo anterior a declaração do tamanho das matrizes é feita da seguinte forma: \textbf{ nome\_variavel[nºlinhas,nºcolunas]}. \par 
A forma de armazenamento e acesso às variáveis será posteriormente discutida nas secções seguintes deste relatório. Neste momento temos especial interesse na especificação da estrutura correcta de programas da nossa linguagem.

\subsubsection{Expressões Regulares e acções resultantes}

Podemos desde já enumerar as expressões regulares necessárias à produção dos tokens que permitam à GIC o agrupamento dos tokens em produções:

\begin{lstlisting}
%{

%}

letter    [a-zA-Z]
digit     [0-9]
ignore    [\ \t\r\n]

%option yylineno

%%

[\%\,\{\}\+\-\(\)\=\>\<\!\;\/\*\[\]\|\&\_]      { return(yytext[0]); }
int                                             { return (TYPE_INT); }

{letter}({letter}|{digit}|\_)*                  { yylval.var = strdup(yytext); return(id); }
{digit}+                                        { yylval.qt = atoi(yytext); return(num); }
\"[^"]+\"                                       { yylval.var = strdup(yytext); return(string); }
\/\/[^\n]*                                      { printf("%s\n",yytext);  }
{ignore}                                        { ; }

%%

int yywrap(){
  return(1);
}
\end{lstlisting}

Como é perceptível pela expressão regular correspondente, vulgo \lstinline${letter}({letter}|{digit}|\_)*$, as variáveis do tipo inteiro terão sempre de ser iniciadas por uma letra (maiúscula ou minúscula), sendo que como segundo caracter poderão ter um número, letra, ou \_.\par Um olhar mais atento às expressão regulares definidas até ao momento permitem-nos identificar um outro tipo de variável -- \textbf{string}, até ao momento não apresentada. Denote que na nossa linguagem não é permitido realizar operações sobre strings (como concatenação ou comparação), apenas será permitir ler e escrever 

\subsubsection{Produções da GIC}



    \chapter{Conclusão} \label{concl}

    Relativamente ao estado final do projecto acredito que foram cumpridos todos os requisitos, sendo que o segundo exercício foi sem dúvida o mais desafiante dada a enorme quantidade de dados e o tipo de dados em si a serem analisados. Reconhecer por si só quais as sequências de caracteres  válidas foi um desafio.\par Naturalmente que a partir da alínea 2.2.b a alínea 2.2.c foi de extrema facilidade, uma vez que todo o trabalho de análise já estava realizado. \par 
      Foi ainda tido em conta a possiblidade de recuperar de erros de leitura na alínea 2.2.b o que facilitou o input correct de dados e posterior tratamento.
      O recurso à biblioteca Glib, recomendada pelo professor José João num aula laboratorial permitiu-me ambientar ainda mais com código desenvolvido por terceiros  e sua correcta análise e integração nos meus projectos.\par 
      Faço um balanço positivo do trabalho prático, pois, apesar de ser extremamente "time consuming" retirei muito conhecimento no que da análise de dados e processamento de linguagens diz respeito.

      \appendix
      \chapter{Código do Programa da alínea 1a}
    \label{completo1a}
   % \lstinputlisting{owl_graph.l} %input de um ficheiro

      \newpage
      \chapter{Código do Programa da alínea 2a}
    \label{completo2a}
%    \lstinputlisting{bib_norm_1.l} %input de um ficheiro

      \newpage
      \chapter{Código do Programa da alínea 2b}
    \label{completo2b}
  %  \lstinputlisting{bib_norm_2.l} %input de um ficheiro


      \newpage
      \chapter{Código do Programa da alínea 3a}
    \label{completo2c}
 %   \lstinputlisting{bib_norm_3.l} %input de um ficheiro



      \end{document}



    \end{document} 
