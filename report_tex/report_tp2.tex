%
% Layout retirado de http://www.di.uminho.pt/~prh/curplc09.html#notas
%

\documentclass{report}

\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}

\usepackage[portuges]{babel}
\usepackage[latin1]{inputenc}
\usepackage{multicol}
\setlength{\columnseprule}{0.4pt}
\setlength{\columnsep}{3em}
\usepackage{url}

\usepackage{listings}

\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\lstset{
  keepspaces=true,  
    tabsize=2,
    basicstyle=\footnotesize,
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    breaklines=true,
    frame=tB,
    % mathescape=true
      % escapeinside={(*@}{@*)}
}

%%                                                       -*- LaTeX -*-
%% Language definition of Yacc/Bison for listings package
%%

%% Yacc
\lstdefinelanguage[]{Yacc}%
{otherkeywords=%
  {\%left,
    \%nonassoc,\%prec,\%right,
    \%start,\%token,\%type,\%union,
    \%\%,\%\{,\%\},|,:,
    \$\$,\$1,\$2,\$3,\$4,\$5,\$6,\$7,\$8,\$9
  },%
  keywords={\%seeREADME},%
    morecomment=[n]{/*}{*/},%
    morestring=[b]{"},%
    sensitive=true
}[keywords,comments,strings]%



\lstdefinelanguage{Bison}[Bison]{Yacc}{}


\usepackage{fix-cm}




\usepackage{xspace}
\usepackage{graphicx}
\usepackage{float}

\parindent=0pt
\parskip=2pt

\setlength{\oddsidemargin}{-1cm}
\setlength{\textwidth}{18cm}
\setlength{\headsep}{-1cm}
\setlength{\textheight}{23cm}

\def\darius{\textsf{Darius}\xspace}
\def\java{\texttt{Java}\xspace}
\def\pe{\emph{Publicação Eletrónica}\xspace}


\title{Processamento de Linguagens (3º ano de Curso)\\ \textbf{Trabalho Prático N 2}\\ Relatório de Desenvolvimento}
\author{Filipe Costa Oliveira\\ a57816  }
\date{\today}

\begin{document}

\maketitle

\newpage

\tableofcontents

\chapter{Introdução} \label{intro}

O presente trabalho prático foca-se no desenvolvimento de  um compilador, que tem como fonte uma linguagem de alto nível (também esta desenvolvida especificamente para este trabalho prático) , gerando código para uma máquina de stack virtual. \par 
Um compilador comum divide o processo de tradução em várias fases. Para o propósito específico desta unidade curricular iremos focar-nos nas seguintes:
\begin{itemize}
\item 1ª Fase de tradução -- Análise Léxica, que agrupa sequências de caracteres em tokens. Recorreremos nesta fase à definição das expressões regulares que permitem definir os tokens.
\item 2ª Fase de tradução --  Reconhecimento(Parsing) da estrutura gramatical do programa, através do agrupamento dos tokens em produções. Recorreremos à definição de uma gramática independente de contexto por forma a definir as estruturas de programa válidas a reconhecer pelo parser. Denote que juntamente com o parsing é realizada a análise semântica, assim como a geração de código associando regras às produções anteriormente descritas.
\end{itemize} 
Começaremos portanto por definir uma linguagem de programação imperativa simples, que chamaremos \textbf{\textit{Algebra}}. A \textbf{\textit{Algebra}} permitirá:
\begin{itemize}
\item declarar e manusear variáveis atómicas do tipo inteiro, com os quais se podem realizar as habituais operações
aritméticas, relacionais e lógicas.
\item declarar e manusear variáveis estruturadas do tipo array (a 1 ou 2 dimensões) de inteiros, em relação aos quais  é apenas permitida a operação de indexação. Aos arrays de duas dimensões, por se tratar de uma linguagem algébrica, chamaremos matrizes, dada a fácil associação a este tipo de variável à sua definição análoga da álgebra linear.
\item efetuar instruções algorítmicas básicas como a atribuição de expressões a variáveis.
\item ler do standard input e escrever no standard output.
\item  efetuar instruções para controlo do fluxo de execução -- condicional e cíclica -- que possam ser aninhadas.
\item definir e invocar subprogramas sem parâmetros mas que possam retornar um resultado atómico.
\end{itemize} 

Na nossa linguagem de programação por questões de estruturação e percepção, teremos como premissa que as variáveis deverão ser declaradas no início do programa, não podendo haver re-declarações, nem utilizações sem declaração prévia. Não será permitida a declaração e associação de um valor inteiro na mesma instrução. Achamos essa solução pouco elegante. Assim, todas as variáveis terão o valor zero após a declaração.\par 

Será desenvolvido portanto o compilador para a \textbf{\textit{Algebra}}, com base na GIC criada acima e recurso ao Gerador Yacc/ Flex.
O compilador de \textbf{\textit{Algebra}} irá gerar pseudo-código, Assembly da Máquina Virtual VM cuja documentação completa está disponibilizada em anexo.\par
Por forma a facilitar e validar o trabalho, à medida que as funcionalidades forem descritas serão apensados  exemplos ilustrativos. \par 
Por fim, serão apresentados um conjunto de testes mais complexos(programas-fonte diversos e respectivo código produzido), que tentam testar de uma forma mais alargadas as funcionalidades da \textbf{\textit{Algebra}}, sendo estes:
\begin{itemize}
\item lidos 3 números, escrever o maior deles.
\item ler N (valor dado) números e calcular e imprimir o seu somatório.
\item contar e imprimir os números pares de uma sequência de N números dados.
\item ler e armazenar os elementos de um vetor de comprimento N, 
  imprimido os valores por ordem crescente após fazer a ordenação do array por trocas diretas.
  \item ler e armazenar os elementos de uma matriz NxM, calculando e imprimindo de seguida a média e máximo dessa matriz.
  \item  invocar e usar num programa  uma função.
  \end{itemize} 


  \chapter{Concepção da Linguagem \textbf{\textit{Algebra}}}
  \label{concepcao}

  \section{Concepção/desenho da Resolução}


  Comecemos por descrever as funcionalidades da linguagem \textbf{\textit{Algebra}}. Tal como descrito anteriormente a \textbf{\textit{Algebra}} permitirá:
  \begin{itemize}

  \item declarar e manusear variáveis atómicas do tipo inteiro, com os quais se podem realizar as habituais operações aritméticas, relacionais e lógicas.
  \item declarar e manusear variáveis estruturadas do tipo array (a 1 ou 2 dimensões) de inteiros, em relação aos quais  é apenas permitida a operação de indexação. Aos arrays de duas dimensões, por se tratar de uma linguagem algébrica, chamaremos matrizes, dada a fácil associação a este tipo de variável à sua definição análoga da álgebra linear.
  \item efetuar instruções algorítmicas básicas como a atribuição de expressões a variáveis.
  \item ler do standard input e escrever no standard output.
  \item  efetuar instruções para controlo do fluxo de execução -- condicional e cíclica -- que possam ser aninhadas.
  \item definir e invocar subprogramas sem parâmetros mas que possam retornar um resultado atómico.

  \end{itemize} 

  \subsection{Uma introdução às variáveis}
  Temos então que as variáveis poderão ser de 3 tipos: inteiros simples, arrays de inteiros, e matrizes de inteiros. Dessa premissa sabemos à partida que o código gerado para a nossa máquina virtual terá que suportar o tipo de variável inteiro. Sabemos ainda que aos tipos de dados mais complexos (arrays e matrizes) apenas é permita a realização de operações de indexação. \par
  Na nossa linguagem de programação por questões de estruturação e percepção, teremos como premissa que as variáveis deverão ser declaradas no início do programa, não podendo haver re-declarações, nem utilizações sem declaração prévia. Não será permitida a declaração e associação de um valor inteiro na mesma instrução(à lá C). Achamos essa solução pouco elegante. 
  Assim, todas as variáveis terão o valor zero após a declaração.\par
  Podemos então aceitar como exemplo as declarações do tipo:

  \lstinputlisting[language=C]{exemplos/1_variaveis.c} %input de um ficheiro

  Dado que toda a porção de código de alto nível julgamos essencial a possibilidade de existência de comentários. Atente no exemplo anterior agora com comentários que facilitam a percepção:

  \lstinputlisting[language=C]{exemplos/2_variaveis.c} %input de um ficheiro


  Tal como poderá confirmar pela última declaração do exemplo anterior a declaração do tamanho das matrizes é feita da seguinte forma: \textbf{ nome\_variavel[nºlinhas,nºcolunas]}. \par 
  A forma de armazenamento e acesso às variáveis será posteriormente discutida nas secções seguintes deste relatório. Neste momento temos especial interesse na especificação da estrutura correcta de programas da nossa linguagem.

  \subsubsection{Expressões Regulares e acções resultantes}
  \label{flex1}
  Podemos desde já enumerar as expressões regulares necessárias à produção dos tokens que permitam à GIC o agrupamento dos tokens em produções:

  \lstinputlisting[language=Yacc]{flex/flex_1_variaveis.l} %input de um ficheiro

  Como é perceptível pela expressão regular correspondente, vulgo \lstinline${letter}({letter}|{digit}|\_)*$, as variáveis do tipo inteiro terão sempre de ser iniciadas por uma letra (maiúscula ou minúscula), sendo que como segundo caracter poderão ter um número, letra, ou \_.\par 

  \subsubsection{Produções da GIC}
  \label{yacc1}
  Com os tokens produzidos pelo parser, podemos iniciar a definição da gramática independente de contexto, resultando nas seguintes produções:

  \lstinputlisting[language=Yacc]{yacc/yacc_1_variaveis.y} %input de um ficheiro


  \subsection{Uma introdução às instruções}
  \label{introducao_instrucoes}

  Da necessidade de realizar operações aritméticas, relacionais e lógicas sobre as variáveis do tipo inteiro atómicas, assim como da necessidade de realizar instruções algorítmicas básicas como a atribuição de expressões a variáveis, surgem as \textbf{instruções} na nossa linguagem \textbf{\textit{Algebra}}.\par 
  Consideramos que qualquer que seja a operação a ser realizada, o seu resultado terá que ser sempre atribuído a alguma variável. \par 
  Podemos desde já enumerar os tipos de operações permitidas na nossa linguagem, associando também o operador utilizador para representar as mesmas:
  \begin{itemize}
  \item Aritmética
  \begin{itemize}
  \item Adição : '+'
  \item Subtração : '-'
  \item Multiplicação inteira : '*'
  \item Divisão Inteira : '/'
  \item Resto da Divisão Inteira : '%'
  \end{itemize}
  \item Relacional
  \begin{itemize}
  \item Igualdade : '=''='
  \item Diferença : '!''='
  \item Superioridade : '$>$'
  \item Superioridade ou Igualdade : '$>$''='
  \item Inferioridade : '$<$'
  \item Inferioridade ou Igualdade : '$<$''='
  \end{itemize}
  \item Lógica
  \begin{itemize}
  \item Negação Lógica : '!'
  \item OR Lógico : '$|$''$|$'
  \item AND Lógico : '\&\&'
  \end{itemize}
  \end{itemize}

  Podemos então aceitar como exemplo de input válido o seguinte código:

  \lstinputlisting[language=C]{exemplos/3_instrucoes.c} %input de um ficheiro

  Como poderá constatar pelas linhas 7 e 8, e tal como é requerido já será possível realizar operações de atribuição. \par 

  \subsubsection{Expressões Regulares e acções resultantes}
  Relativamente às expressões regulares necessárias para proceder correctamente ao parsing não é necessário alterar os ficheiro Flex presente na seção \ref{flex1}, uma vez que a expressão regular 
  \lstinline$[\%\,\{\}\+\-\(\)\=\>\<\!\;\/\*\[\]\|\&\_]$ já engloba todos os símbolos necessárias até à fase actual.

  \subsubsection{Produções da GIC}
  \label{yacc2}
  Tomando por base o ficheiro Yacc presente na seção \ref{yacc1}, podemos proceder à adição de produções por forma a reconhecer as estruturas de programa válidas até ao momento.

  \lstinputlisting[language=Yacc]{yacc/yacc_2_instrucoes.y} %input de um ficheiro

  As produções relativas às expressões lógicas e relacionais terão especial importância na adição da capacidade de inclusão de instruções para controlo do fluxo de execução -- condicional e cíclica -- que possam ser aninhadas, na nossa linguagem \textbf{\textit{Algebra}}, que passaremos de seguida e especificar.

  \subsection{Uma introdução às instruções condicionais e cíclicas}
  \label{introducao_condicionais}

  \subsubsection{Instruções condicionais}
  Por forma à \textbf{\textit{Algebra}} ter utilidade real, é necessária a inclusão de instruções que permitam mudar o fluxo de execução. Necessitamos portanto de incluir a possibilidade de declarar instruções condicionais na nossa linguagem. \par 
  Para criarmos uma estrutura condicional, deveremos recorrer a expressões do tipo: 
  \begin{center}
  \textbf{if} ( Expressão Lógica )\par  \textbf{then}  [\{Instruções\}$|$Instrução] \par \textbf{else} [\{Instruções\}$|$Instrução$|$/*empty*/]\par 
  \end{center}

  Pela análise do esquema anterior sabemos que o bloco de código \textbf{else} [\{Instruções\}$|$Instrução$|$/*empty*/] é opcional, sendo que, em caso de os fluxos de execução representarem apenas uma instrução na nossa linguagem \textbf{\textit{Algebra}} não existe a necessidade de inclusão de parêntesis entre os diferentes fluxos.\par 
  Tal como requerido, deverá ser também possível o aninhamento de instruções condicionais.\par 
  Podemos então aceitar como exemplo de input válido o seguinte código:
  \lstinputlisting[language=C]{exemplos/4_condicional.c} %input de um ficheiro

  \subsubsection{Instruções cíclicas}

  Uma instrução cíclica irá permitir ao programador executar um determinado bloco de código um determinado número de vezes, de acordo com uma condição lógica.\par 
  Para criarmos uma estrutura cíclica, deveremos recorrer a expressões do tipo: 
  \begin{center}
  \textbf{do}   [\{Instruções\}$|$Instrução]\par 
  \textbf{while} ( Expressão Lógica )\par\par 
  \end{center}
  Pela análise do esquema anterior sabemos que em caso de o fluxo de execução representar apenas uma instrução na nossa linguagem \textbf{\textit{Algebra}} não existe a necessidade de inclusão de parêntesis entre as palavras reservadas  \textbf{do} e  \textbf{while}.\par 

  Tal como requerido, deverá ser também possível o aninhamento de instruções condicionais.\par 
  Podemos então aceitar como exemplo de input válido o seguinte código:
  \lstinputlisting[language=C]{exemplos/5_ciclo.c} %input de um ficheiro

  \subsubsection{Expressões Regulares e acções resultantes}
  \label{flex3}

  Tomando por base o ficheiro Flex  presente na seção \ref{flex1}, podemos proceder à adição de expressões regulares por forma a produzir os tokens necessários para o correcto reconhecimento pela GIC.
  \lstinputlisting[language=Yacc]{flex/flex_3_condicionais.y} %input de um ficheiro


  \subsubsection{Produções da GIC}
  \label{yacc3}
  Tomando por base o ficheiro Yacc presente na seção \ref{yacc1}, podemos proceder à adição de produções por forma a reconhecer as estruturas de programa válidas até ao momento.

  \lstinputlisting[language=Yacc]{yacc/yacc_3_condicionais.y} %input de um ficheiro


  \subsection{Uma introdução às instruções de leitura do  standard input e escrita no standard output}
  \label{introducao_input_output}


  \subsubsection{Instruções de leitura do standard input}
  \label{introducao_input}
  Por forma à \textbf{\textit{Algebra}} poder efectuar operações de leitura do standard input, é necessária a inclusão de instruções que permitam a leitura de inteiros, e atribuição do valor inteiro a uma variável. \par Consideramos que só fará sentido ler dados do standard input se os mesmos foram atribuídos. "Ler por Ler" do Standard Input não representa nenhuma mais valia para a linguagem. \par 
  Podemos então aceitar como exemplo de input válido o seguinte código:

  \lstinputlisting[language=C]{exemplos/6_input.c} %input de um ficheiro

  \subsubsection{Instruções de escrita no standard output}
  \label{introducao_output}
  Uma instrução de escrita no standard output permitirá ao programador imprimir o valor de variáveis do tipo inteiro atómicas, variáveis do tipo array e matriz, assim como de valores inteiros directamente, e ainda de variáveis do tipo string, vulgo uma sequência de caracteres iniciada por " e terminada por ". \par 
  Denote que na nossa linguagem não é permitido realizar operações sobre strings (como concatenação ou comparação), apenas será permitir escrever as mesmas no standard output.\par
  Ora, retomando o exemplo da seção \ref{introducao_input}, podemos agora torná-lo mais completo com adição de instruções de escrita no standard input.
  \lstinputlisting[language=C]{exemplos/7_output.c} %input de um ficheiro

  \subsubsection{Expressões Regulares e acções resultantes}
  \label{flex4}

  Tomando por base o ficheiro Flex  presente na seção \ref{flex3}, podemos proceder à adição de expressões regulares por forma a produzir os tokens necessários para o correcto reconhecimento pela GIC.
  \lstinputlisting[language=Yacc]{flex/flex_4_input_output.l} %input de um ficheiro


  \subsubsection{Produções da GIC}
  \label{yacc4}
  Tomando por base o ficheiro Yacc presente na seção \ref{yacc3}, podemos proceder à adição de produções por forma a reconhecer as estruturas de programa válidas até ao momento.

  \lstinputlisting[language=Yacc]{yacc/yacc_4_input_output.y} %input de um ficheiro

  Possuímos neste momento todas as ferramentas necessárias para a escrita de programas na linguagem de alto nível \textbf{\textit{Algebra}} que recorram aos seguintes requisitos:

  \begin{itemize}
  \item declarar e manusear variáveis atómicas do tipo inteiro, com os quais se podem realizar as habituais operações aritméticas, relacionais e lógicas.
  \item declarar e manusear variáveis estruturadas do tipo array e matrizes de inteiros, em relação aos quais  é apenas permitida a operação de indexação. 
  \item efetuar instruções algorítmicas básicas como a atribuição de expressões a variáveis.
  \item ler do standard input e escrever no standard output.
  \item  efetuar instruções para controlo do fluxo de execução -- condicional e cíclica -- que possam ser aninhadas.
  \end{itemize} 

  Resta-nos passar à adição de funcionalidades que permitam definir e invocar subprogramas sem parâmetros mas que possam retornar um resultado atómico.


  \subsection{Uma introdução aos subprogramas}
  \label{introducao_subprogramas}
  Por  forma a definir e invocar subprogramas sem parâmetros mas que possam retornar um resultado atómico, é necessária a inclusão de instruções que permitam a declaração de blocos de código que apenas serão executados quando invocada a função onde estes estão inscritos.\par 
  Ora, mantendo a premissa de estruturação e percepção já existente, decidimos que as declarações de funções terão de ocorrer depois das declarações de variáveis, e antes do início do programa principal. \par 
  Não será permitida redeclaração de funções, nem utilização de funções no programa principal sem declaração prévia.  \par 
  Entendemos que especificamente para a na nossa linguagem de alto nível, todos os subprogramas retornam sempre uma variável com valor inteiro. 
  Tendo em conta o descrito anteriormente, para criarmos um subprograma, deveremos recorrer a instruções do tipo: 
  \begin{center}
  \textbf{declare} nome\_função ( ) \{ \par  Instruções \par  \textbf{return} valor\_inteiro ; \}
  \end{center}

  Para invocarmos um subprograma, deveremos a instruções do tipo:

  \begin{center}
  variável = \textbf{call} nome\_função ( ) ; 
  \end{center}


  \subsubsection{Expressões Regulares e acções resultantes}
  \label{flex5}

  Tomando por base o ficheiro Flex  presente na seção \ref{flex4}, podemos proceder à adição de expressões regulares por forma a produzir os tokens necessários para o correcto reconhecimento pela GIC.
  \lstinputlisting[language=Yacc]{flex/flex_5_funcoes.l} %input de um ficheiro

  \subsubsection{Produções da GIC}
  \label{yacc5}
  Tomando por base o ficheiro Yacc presente na seção \ref{yacc4}, podemos proceder à adição de produções por forma a reconhecer as estruturas de programa válidas até ao momento.

  \lstinputlisting[language=Yacc]{yacc/yacc_5_funcoes.y} %input de um ficheiro

  Concluímos neste momento o estudo sobre a linguagem \textbf{\textit{Algebra}}, e consequentemente a gramática independente de contexto e analisador léxico. 

  \chapter{Introdução à Máquina Virtual}

  Concluída a gramática independente de contexto e o analisador léxico, o próximo passo será dar a conhecer a máquina para a qual pretendemos gera código máquina. Trata-se duma maquina de pilhas, composta duma pilha de execução, duma pilha de chamadas, duma zona de código, de duas heaps e de
  quatro registos.\par 

  A pilha de execução contém valores, que podem ser inteiros, reais ou endereços.\par
  As duas heaps contêm, respectivamente, cadeias de caracteres (strings) e blocos estruturados.\par
  Cada um destes tipos de dados é referenciado por endereços. Cada bloco estruturado contem um certo número de valores (do mesmo tipo dos valores que se podem encontrar na pilha).
  Um endereço pode apontar para quatro tipos de informação: para código, para a pilha, para um bloco estruturado ou para uma string.
  Três registos permitam o acesso a diferentes partes da pilha:
  \begin{itemize}
  \item  O registo sp (stack pointer) aponta para o topo corrente da pilha. Ele aponta para a primeira célula livre da pilha.
  \item  O registo fp (frame pointer) aponta para o endereço de base das variáveis locais.
  \item  O registo gp contem o endereço de base das variáveis globais.
  \end{itemize}
  A máquina possui um registo pc que aponta para a instrução corrente (da zona de código) por executar.\par 
  A pilha de chamada permite guardar as chamadas: contém pares de apontadores (i, f). O endereço i guarda o registo de instrução pc e f o registo fp.

  \section{As instruções}

  As instruções são designadas por um nome e podem aceitar um ou dois parâmetros. Estes podem ser:
  \begin{itemize}
  \item constantes inteiras.
  \item  constantes reais.
  \item cadeias de caracteres delimitadas por aspas. Estas cadeias de caracteres seguem as mesmas regras de formatação que as cadeias da linguagem C 
  (em particular no que diz respeito aos caracteres especiais como $\backslash $ ", $\backslash $ n ou $\backslash $$\backslash $ ).
  \item uma etiqueta simbólica designando uma zona no código.
  \end{itemize}

  Para o caso específico da linguagem de alto nível que nos propomos a desenvolver temos especial interesse em instruções que lidem com:

  \begin{itemize}
  \item constantes inteiras.
\item cadeias de caracteres delimitadas por aspas. (apenas necessárias para as operações de leitura e escrita)
  \item uma etiqueta simbólica designando uma zona no código.
  \end{itemize}


  \subsection{Operações de base e assunções}
  Por forma a gerarmos correctamente código máquina devemos ter em consideração os seguintes pontos:

  \begin{itemize}

  \item   As operações aritméticas  envolvem os valores do topo e do sub-topo da pilha. \par 
  Neste caso quando a operação envolvida é executada, os dois argumentos são retiradas da pilha
(refira-se à secção das convenções para perceber o que é retirar valores da pilha) 
  e o resultado é então empilhado. \par 
  \item O resultado duma operação de comparação é um inteiro que vale 0 ou 1. 
  \item  O inteiro 0 representa o valor booleano falso enquanto o valor 1 representa o valor verdade.
  \end{itemize}

  De todas as operações disponíveis, apresentamos de seguida aquelas sobre as quais a GIC irá incluir na geração de código máquina. Atente na separação por tipo de operação:

  \subsubsection{Operações sobre inteiros}

  \begin{table}[H]
  \label{table:operacoes_inteiros}
  \centering
  \begin{tabular}{ | L{2cm} | L{2cm} |  R{10cm} | }


  \hline
  Instrução & Argumentos & Descrição
  \\ \hline \hline

  ADD & & tira da pilha n e m que devem ser inteiros e empilha o resultado
  m + n
  \\ \hline 

  SUB & & tira da pilha n e m que devem ser inteiros e empilha o resultado
  m - n
  \\ \hline

  MUL & &  tira da pilha n e m que devem ser inteiros e empilha o resultado
  m $×$ n
  \\ \hline

  DIV & & tira da pilha n e m que devem ser inteiros e empilha o resultado
  m$/$n
  \\ \hline 

  MOD& &  tira da pilha n e m que devem ser inteiros e empilha o resultado
  m mod n
  \\ \hline 

  NOT& &  tira da pilha n que deve ser um inteiro e empilha o resultado n = 0
  \\ \hline 

  INF & & tira da pilha n e m que devem ser inteiros e empilha o resultado
  m $<$ n
  \\ \hline

  INFEQ & & tira da pilha n e m que devem ser inteiros e empilha o resultado
  m  $<=$n
  \\ \hline 

  SUP & & tira da pilha n e m que devem ser inteiros e empilha o resultado
  m $>$ n
  \\ \hline 

  SUPEQ & & tira da pilha n e m que devem ser inteiros e empilha o resultado
  m $>=$ n
  \\ \hline 
  \end{tabular}
  \end{table}

  \subsubsection{Operações sobre endereços}

  \begin{table}[H]
  \label{table:operacoes_enderecos}
  \centering
  \begin{tabular}{ | L{2cm} | L{2cm} |  R{10cm} | }
  \hline
  Instrução & Argumentos & Descrição
  \\ \hline \hline
  PADD  & &  tira da pilha n que deve ser um inteiro e a que deve ser um endereço
  e empilha o endereço a + n
  \\ \hline 

  \end{tabular}
  \end{table}



  \subsubsection{Igualdade}

  \begin{table}[H]
  \label{table:igualdade}
  \centering
  \begin{tabular}{ | L{2cm} | L{2cm} |  R{10cm} | }
  \hline
  Instrução & Argumentos & Descrição
  \\ \hline \hline

  EQUAL   & &  tira da pilha n seguido de m que devem ser do mesmo tipo e empilha
  o resultado de n = m
  \\ \hline 

  \end{tabular}
  \end{table}




  \subsubsection{Conversões}


  \begin{table}[H]
  \label{table:conversoes}
  \centering
  \begin{tabular}{ | L{2cm} | L{2cm} |  R{10cm} | }
  \hline
  Instrução & Argumentos & Descrição
  \\ \hline \hline


  ATOI   &   & retira da pilha o endereço duma string e empilha a sua conversão
  em inteiro. Tal falha quando a string não representa um inteiro.
  \\ \hline 

  \end{tabular}
  \end{table}



  \subsubsection{Manipular dados}

  \begin{table}[H]
  \label{table:manipular_dados}
  \centering
  \begin{tabular}{ | L{2cm} | L{2cm} |  R{10cm} | }
  \hline
  Instrução & Argumentos & Descrição
  \\ \hline \hline

  PUSHI & n inteiro   &  empilha n
  \\ \hline 
  PUSHN  & n inteiro   &  empilha n vezes o valor inteiro 0

  \\ \hline 
  PUSHS & n string   &  arquiva n na zona das strings e empilha o endereço
  \\ \hline 
  PUSHG & n inteiro   &  empilha o valor localizado em gp[n]
  \\ \hline 
  PUSHGP   & &  empilha o valor do registo gp
  \\ \hline 
  LOAD  & n inteiro   &  retira da pilha um endereço a e empilha o valor na pilha ou
  no heap (dependendo do tipo de a) em a[n]
  \\ \hline 
  LOADN  &  &  retira da pilha um inteiro n, um endereço a e empilha o valor
  na pilha ou no heap (dependendo do tipo de a) em a[n]
  \\ \hline 
  STOREG & n inteiro   &  retira um valor da pilha e arquiva-a na pilha em gp[n]
  \\ \hline 
  STORE & n inteiro   &  retira da pilha um valor v e um endereço a, arquiva v
em a[n]na pilha ou na heap (dependendo do tipo de a)
  \\ \hline 
  STOREN   & &  retira da pilha um valor v, um inteiro n e um endereço
  a, arquiva v no endereço a[n] na pilha ou na heap
  \\ \hline 

  \end{tabular}
  \end{table}

  \subsubsection{Input-Output}

  \begin{table}[H]
  \label{table:input}
  \centering
  \begin{tabular}{ | L{2cm} | L{2cm} |  R{10cm} | }
  \hline
  Instrução & Argumentos & Descrição
  \\ \hline \hline
  WRITEI   & &  retira um inteiro da pilha e imprime o valor na saída standard
  \\ \hline 
  WRITES  &  &  retira um endereço de uma string da pilha e imprime a string correspondente
  na saída standard
  \\ \hline 
  READ  &  &  lê uma string do teclado (concluída por um "$\backslash$n") e arquiva esta
  string (sem o "$\backslash$n") na heap e coloca (empilha) o endereço na pilha..
  \\ \hline 
  \end{tabular}
  \end{table}

  \subsubsection{Operações de controlo}

  \begin{table}[H]
  \label{table:controlo}
  \centering
  \begin{tabular}{ | L{2cm} | L{2cm} |  R{10cm} | }
  \hline
  Instrução & Argumentos & Descrição
  \\ \hline \hline

  JUMP &  label etiqueta &  atribui ao registo pc o endereço no código que corresponde a
  label   (pode ser um inteiro ou um valor simbólico).
  \\ \hline 
  JZ & label etiqueta &  retira da pilha um valor. Se este for nulo então é atribuído
  ao registo pc o endereço correspondente à label, incrementa
  simplesmente pc de 1, caso contrário.
  \\ \hline 

  PUSHA & label etiqueta &  empilha o endereço de programa correspondente a etiqueta
  label
  \\ \hline 

  CALL &  & retira da pilha um endereço de programa a, salvaguarda pc e fp na
  pilha das chamadas, afecta a fp o valor corrente de sp e a pc o valor
  de a.
  \\ \hline 
  RETURN & &  afecta a sp o valor corrente de fp, restaura da pilha de chamadas
  os valores de fp e de pc, incrementa pc de 1 por forma a encontrar
  a instrução a seguir a chamada.
  \\ \hline 
  \end{tabular}
  \end{table}

  \subsubsection{Inicialização e fim}

  \begin{table}[H]
  \label{table:inicializacao}
  \centering
  \begin{tabular}{ | L{2cm} | L{2cm} |  R{10cm} | }
  \hline
  Instrução &  Argumentos & Descrição
  \\ \hline \hline

  START &  &  Afecta o valor de sp a fp
  \\ \hline 
  NOP &  & não faz nada.
  \\ \hline 
  ERR & x string &  levanta um erro com a mensagem x.
  \\ \hline 
  STOP & &  pára a execução do programa
  \\ \hline 

  \end{tabular}
  \end{table}

  \subsubsection{Operações necessárias e não presentes em instruções da VM}

  Existem operações lógicas e relacionais que não estão disponíveis na VM, nomeadamente:

  \begin{itemize}
  \item Negação Lógica
  \item OR Lógico
  \item AND Lógico
  \item NOT EQUAL Lógico
  \end{itemize}

  No entanto recorrendo a instruções presentes nas tabelas \ref{table:operacoes_inteiros} e \ref{table:manipular_dados}, referentes a operações sobre inteiros e a manipulação de dados, conseguimos obter o comportamento lógico dessas mesmas operações.\par 
  Relativamente às instruções de controlo de fluxo seria útil a presença da instrução \textbf{jnz} 
  que deveria retirar da pilha um valor e se esse fosse não nulo então seria atribuído  ao registo pc o endereço correspondente à label. No entanto esta lacuna é também contornável como veremos nas secções seguintes do relatório.


  \chapter{Geração de Código Máquina -- de Produções a Assembly }


  Especificadas as instruções disponíveis na máquina virtual, assim como a sua forma de funcionamento, resta-nos incluir nas produções da gramática independente de contexto a geração de código máquina correspondente. 

  \section{Métodos e variáveis auxiliares à geração de código máquina}
  Por forma a implementar correctamente as funcionalidades propostas, é necessário o conhecimento de alguns dados gerais do programa a ser analisado. \par 
  Relativamente às variáveis necessitamos de possuir informação relativamente ao seu tipo (se é inteiro atómico, array, matriz ou função), tamanho total ocupado, dimensões (quando aplicável), 	e posição relativamente ao global pointer.\par 
  Ora tal informação é guardada no array de estruturas var\_table, que possui capacidade para armazenar dados relativos a 1000 variáveis. O array \textbf{ia[x]}\footnote{Tal solução foi pensada tendo por base forma de representação de matrizes esparsas CSR, daí advindo o nome da variável.} permite de forma rápida saber qual o tamanho total ocupado pela variável presente no índice x da var\_table.\par
  É mantido também estado sobre o número de condicionais e ciclos abertos e declarados até ao momento.\par
  De seguida apresentam-se todas a variáveis auxiliares assim como a assinatura das funções às quais se recorre para implementar todas as funcionalidades.

  \lstinputlisting[language=C]{yacc/algebric_code.y} %input de um ficheiro

  À medida que formos recorrendo às funções auxiliares iremos apresentar o respectivo código C.

  \section{Geração de código máquina nas produções}

  \subsection{Início e término do programa}
  Comecemos pela inclusão das instruções \textbf{START} e \textbf{STOP}. Estas iniciam e param a máquina virtual. Assim sendo, as mesmas serão incluídas na produção:

  \lstinputlisting[language=Yacc]{yacc/yacc_6_start_stop.y} %input de um ficheiro

  Sendo o seguinte código associado à produção:

  \lstinputlisting[language=Yacc]{yacc/yacc_6_start_stop_code.y} %input de um ficheiro

  \subsection{Declarações de variáveis}
  Sempre que são reconhecidas as produções de declarações de variáveis é necessário alocar o espaço correspondente às mesmas na stack. Ora, assim sendo, o conjunto de instruções de código máquina que permitirão a correcta declaração de variáveis será incluído nas produções:
  \lstinputlisting[language=Yacc]{yacc/yacc_7_declaration.y} %input de um ficheiro

  Sendo o seguinte código associado à produção:
  \lstinputlisting[language=Yacc]{yacc/yacc_7_declaration_code.y} %input de um ficheiro

  Ora, o código C adicionado às produções recorre a 5 métodos auxiliares ainda não definidos. De seguida apresentam-se os mesmos:
  \subsubsection{Método auxiliar: void assert\_no\_redeclared\_var( char* varname ,var\_type type);}
  \label{assert_no_redeclared}
  \lstinputlisting[language=C]{yacc/assert_no_redeclared_var.c} %input de um ficheiro

  \subsubsection{Método auxiliar: void compile\_error( char* message);}
  \label{compile_error}
  \lstinputlisting[language=C]{yacc/compile_error.c} %input de um ficheiro

  \subsubsection{Método auxiliar: void insert\_int(char* varname);}
  \label{insert_int}
  \lstinputlisting[language=C]{yacc/insert_int.c} %input de um ficheiro

  \subsubsection{Método auxiliar: void insert\_array(char* varname, int size);}
  \label{insert_array}
  \lstinputlisting[language=C]{yacc/insert_array.c} %input de um ficheiro

  \subsubsection{Método auxiliar: void insert\_matrix(char* varname, int rows, int cols);}
  \label{insert_matrix}
  \lstinputlisting[language=C]{yacc/insert_matrix.c} %input de um ficheiro


  \subsection{Declarações de subprogramas}
  Sempre que são reconhecidas as produções de declarações de subprogramas é necessário alocar o espaço correspondente ao valor inteiro atómico a retornar na stack na stack.\par  Relativamente à invocação de funções é necessário também incluir os código máquina e \textbf{CALL} e \textbf{RETURN}, sendo necessária correcta marcação das zonas do código máquina produzido através de labels. \par 
  É garantida a não execução do código da função através da inclusão de um salto para o fim da função antes do conjunto de instruções pertencentes à mesma. \par 
  Ora, assim sendo, o conjunto de instruções de código máquina que permitirão a correcta declaração e invocação de subprogramas será incluído nas produções:
  \lstinputlisting[language=Yacc]{yacc/yacc_8_function_declaration.y} %input de um ficheiro

  Sendo o seguinte código associado à produção:
  \lstinputlisting[language=Yacc]{yacc/yacc_8_function_declaration_code.y} %input de um ficheiro

  Denote que foi adicionada instrução \textbf{NOP} após a label do subprograma dado que a máquina virtual "saltava" a instrução seguinte à label sem a correr. Desta forma garantimos a correcta implementação da funcionalidade. \par 
  Ora, o código C adicionado às produções recorre a 2 métodos auxiliares ainda não definidos. De seguida apresentam-se os mesmos:
  \subsubsection{Método auxiliar: void insert\_function ( char* function\_name );}
  \label{insert_function}
  \lstinputlisting[language=C]{yacc/insert_function.c} %input de um ficheiro

  \subsubsection{Método auxiliar: void assert\_declared\_var( char* varname, var\_type type);}
  \label{assert_declared}
  \lstinputlisting[language=C]{yacc/assert_declared_var.c} %input de um ficheiro

  \subsection{Atribuição de valores a variáveis}
  Sempre que são reconhecidas as produções de atribuição de valores a variáveis é necessário 
  incluir os código máquina responsáveis por tais operações. Ora, a não terminal \textbf{Assignement}
  dá origem a duas produções, sendo estas a atribuição de valores a variáveis do tipo inteiro atómico, e a atribuição de variáveis do tipo array ou matriz.\par 
  Denote que o não terminal  \textbf{Assignement\_Value}
  dá origem a três produções, cada uma representando uma atribuição de "origem" distinta. Pela análise das produções, podemos retirar que as atribuições poderão ser de valores lidos do standard input, de valores retornados por funções ou do resultado de expressões aritméticas.\par 
  O conjunto de instruções de código máquina que permitirão a correcta atribuição de valores a variáveis será incluído nas produções:
  \lstinputlisting[language=Yacc]{yacc/yacc_9_assignement.y} %input de um ficheiro

  Sendo o seguinte código associado à produção:
  \lstinputlisting[language=Yacc]{yacc/yacc_9_assignement_code.y} %input de um ficheiro

  Aprofundemos a nossa análise aos não terminais \textbf{Arithmetic\_Expression} e \textbf{Read\_Stdin}, dado que já analisamos anteriormente o não terminal \textbf{Function\_Invocation}.


  \subsubsection{Análise às produções do não terminal Arithmetic\_Expression }

  Sempre que são reconhecidas as produções que reflectem expressões aritméticas é necessário  incluir os código máquina responsáveis por tais operações. \par 
  Desta forma, o conjunto de instruções de código máquina que permitirão a correcta atribuição de valores a variáveis será incluído nas produções:
  \lstinputlisting[language=Yacc]{yacc/yacc_11_arithmetic_expression.y} %input de um ficheiro

  Sendo o seguinte código associado à produção:
  \lstinputlisting[language=Yacc]{yacc/yacc_11_arithmetic_expression_code.y} %input de um ficheiro

  Como pode constatar pela produção \textbf{Factor : Vectors ;} é necessário analisarmos também o não terminal Vectors dado que é o responsável por gerar código máquina para aceder a valores do tipo array ou matriz. Analisemos de seguida esse não terminal.
  \subsubsection{Análise às produções do  não terminal Vectors }

  Sempre que são reconhecidas as produções que reflectem a utilização de variáveis do tipo array ou matriz  é necessário  incluir os código máquina responsáveis por aceder aos valores das mesmas. \par 
  Antes de procedermos à especificação do acesso às posições do gp[n] que contêm os dados relativos às matrizes e arrays, devemos explicitar a forma com esses mesmos dados são armazenados.\par 

  Considere o exemplo de declaração de uma matriz de tamanho 2x4:
  \lstinputlisting[language=C]{exemplos/8_matriz.c} %input de um ficheiro

  O dados da matriz são declarados de forma "row-wise" (linha a linha), sendo que, quando pretendemos aceder por exemplo ao elemento localizado na 2ª linha 4ª coluna, com "zero indexing", estaremos a aceder à posição matriz\_exemplo[1,3], sendo que a posição de memória correspondente é dada por 1(linha do elemento) * nº de colunas + 3 (coluna do elemento).\par 
  Por forma a facilitar a compreensão da localização relativa ao gp, o mesmo exemplo foi transformado em ilustrações:

  \begin{figure}[H]
  \centering
  \includegraphics[width=0.2\columnwidth]{PNG/matriz-00.png}
  \caption{Declaração da variável do tipo matriz de tamanho 2x4 pela linha de código : int matriz\_exemplo[2,4]; }
  \label{fig:ex0}
  \end{figure}

  \begin{figure}[H]
  \centering
  \includegraphics[width=0.2\columnwidth]{PNG/matriz-01.png}
  \caption{Atribuição do valor 5 à posição da matriz (1ª linha, 2ª coluna) pela linha de código : matriz\_exemplo[0,1] = 5; }
  \label{fig:ex1}
  \end{figure}

  \begin{figure}[H]
  \centering
  \includegraphics[width=0.2\columnwidth]{PNG/matriz-02.png}
  \caption{Atribuição do valor 10  à posição da matriz (2ª linha, 4ª coluna) pela linha de código : matriz\_exemplo[1,3] = 10; }
  \label{fig:ex2}
  \end{figure}

  O acesso à memória pode ser descrito pelo seguinte esquema:
  \begin{figure}[H]
  \centering
  \includegraphics[width=0.2\columnwidth]{PNG/matriz-03.png}
  \caption{Ilustração do acesso à memória -- "row wise"}
  \label{fig:ex3}
  \end{figure}


  Agora com este conhecimento relativo à forma como os dados estão posicionados podemos analisar o conjunto de produções responsáveis por traduzir esta forma de acesso em instruções de código máquina:
  \lstinputlisting[language=Yacc]{yacc/yacc_17_vectors.y} %input de um ficheiro

  Sendo o seguinte código associado à produção:
  \lstinputlisting[language=Yacc]{yacc/yacc_17_vectors_code.y} %input de um ficheiro

  Ora, o código C adicionado às produções recorre a 3 métodos auxiliares ainda não definidos. De seguida apresentam-se os mesmos:
  \subsubsection{Método auxiliar: int global\_pos(char* varname);}
  \label{global_pos}
  \lstinputlisting[language=C]{yacc/global_pos.c} %input de um ficheiro

  \subsubsection{Método auxiliar: int is\_vector(char* varname);}
  \label{is_vector}
  \lstinputlisting[language=C]{yacc/is_vector.c} %input de um ficheiro

  \subsubsection{Método auxiliar: int get\_matrix\_ncols(char* varname);}
  \label{get_matrix_nclos}
  \lstinputlisting[language=C]{yacc/get_matrix_nclos.c} %input de um ficheiro

  Podemos, em jeito de validação confirmar que o comportamento descrito é mesmo o verificado na execução da máquina virtual:

  \begin{figure}[H]
  \centering
  \includegraphics[width=1\columnwidth]{PNG/vm_8_matriz.png}
  \caption{Confirmação do modo de registo em stack das variáveis do tipo matriz -- "row wise"}

  \label{fig:ex8}
  \end{figure}

  \subsubsection{Análise às produções do  não terminal Read\_Stdin }

  Sempre que são reconhecidas as produções que reflectem leitura do standard input é necessário  incluir os código máquina responsáveis por tal operação. \par 
  Tal como foi descrito anteriormente, a leitura do standard input é apenas permitida aquando da associação do valor lido a uma variável.\par 
  O conjunto de instruções de código máquina que permitirão a correcta atribuição de valores a variáveis provenientes do standard input será dado pelas seguintes produções:
  \lstinputlisting[language=Yacc]{yacc/yacc_10_read_stdin.y} %input de um ficheiro

  Sendo o seguinte código associado à produção:
  \lstinputlisting[language=Yacc]{yacc/yacc_10_read_stdin_code.y} %input de um ficheiro

  \subsection{Análise às produções do não terminal Logical\_Expression }
  \label{logical_expression}
  Sempre que são reconhecidas as produções que reflectem expressões lógicas é necessário incluir os código máquina responsáveis por tais operações. \par 
  As expressões lógicas e relacionais serão de extrema importância nas produções que envolvam condicionais e ciclos. Debruçar-nos-emos sobre essas instruções nas seções seguintes deste relatório.\par 
  Desta forma, o conjunto de instruções de código máquina que permitirão a correcta produção de valores lógicos 1 (verdade) e 0 (falso) serão incluídas nas produções:
  \lstinputlisting[language=Yacc]{yacc/yacc_12_logical_expression.y} %input de um ficheiro

  Sendo o seguinte código associado à produção:
  \lstinputlisting[language=Yacc]{yacc/yacc_12_logical_expression_code.y} %input de um ficheiro

  Denote que tal como havia sido descrito anteriormente foi necessário proceder à inclusão de instruções de código máquina que conjugadas tenham o comportamento lógico da negação, OR e AND.\par 
  Nas produções aqui apresentados é introduzido um outro não terminal -- \textbf{Relational\_Expression}. Iremos analisar as produções com este relacionadas de seguida.


  \subsection{Análise às produções do não terminal Relational\_Expression }

  Sempre que são reconhecidas as produções que reflectem expressões relacionais é necessário incluir os código máquina responsáveis por tais operações. \par 
  Desta forma, o conjunto de instruções de código máquina que permitirão a correcta produção de valores lógicos 1 (verdade) e 0 (falso) com base em relações serão incluídas nas produções:
  \lstinputlisting[language=Yacc]{yacc/yacc_13_relational_expression.y} %input de um ficheiro

  Sendo o seguinte código associado à produção:
  \lstinputlisting[language=Yacc]{yacc/yacc_13_relational_expression_code.y} %input de um ficheiro

  No seguimento do sucedido na seção \ref{logical_expression} foi também para este tipo de produções necessário proceder à inclusão de instruções de código máquina que conjugadas tenham o comportamento lógico da negação de igualdade. Para os restantes operadores relacionais existiam instruções relacionais directamente presentes na linguagem máquina.\par 


  \subsection{Instruções condicionais }

  Sempre que são reconhecidas as produções que reflectem instruções condicionais é necessário incluir os código máquina que permitam fluxos de execução distintos. Tal é realizado recorrendo a labels e à análise do valor lógico da condição em teste. Em caso de valor lógico 1 (verdade) é efectuado um salto para a label \textbf{inthen[nº do condicional]}. Quando se verifica o valor lógico 0 (falso) na condição é efectuado um salto para a label \textbf{inelse[nº do condicional]}.\par 
  O conjunto de instruções de código máquina que permitirão a correcta ordem de execução de fluxos de instruções com base em instruções condicionais serão incluídas nas seguintes produções:
  \lstinputlisting[language=Yacc]{yacc/yacc_14_conditional.y} %input de um ficheiro

  Sendo o seguinte código associado à produção:
  \lstinputlisting[language=Yacc]{yacc/yacc_14_conditional_code.y} %input de um ficheiro


  Ora, o código C adicionado às produções recorre a 3 métodos auxiliares ainda não definidos. De seguida apresentam-se os mesmos:
  \subsubsection{Método auxiliar: int open\_conditional();}
  \label{open_conditional}
  \lstinputlisting[language=C]{yacc/open_conditional.c} %input de um ficheiro

  \subsubsection{Método auxiliar: int close\_conditional();}
  \label{close_conditional}
  \lstinputlisting[language=C]{yacc/close_cycle.c} %input de um ficheiro

  \subsubsection{Método auxiliar: int current\_conditional();}
  \label{current_conditional}
  \lstinputlisting[language=C]{yacc/current_conditional.c} %input de um ficheiro





  \subsection{Instruções cíclicas }

  Sempre que são reconhecidas as produções que reflectem instruções cíclicas é necessário incluir os código máquina responsáveis por tais operações. \par 
  Desta forma, enquanto a condição de paragem mantiver o valor lógico 1 (verdade) é efectuado um salto para o início do ciclo. Quando se verifica o valor lógico 0 (falso) na condição, é prosseguida a execução com salto para a label de término do ciclo.\par 
  O conjunto de instruções de código máquina que permitirão a correcta ordem de execução de instruções com base em instruções cíclicas serão incluídas nas seguintes produções:
  \lstinputlisting[language=Yacc]{yacc/yacc_15_cycle.y} %input de um ficheiro

  Sendo o seguinte código associado à produção:
  \lstinputlisting[language=Yacc]{yacc/yacc_15_cycle_code.y} %input de um ficheiro

  Ora, o código C adicionado às produções recorre a 2 métodos auxiliares ainda não definidos. De seguida apresentam-se os mesmos:
  \subsubsection{Método auxiliar: int open\_cycle();}
  \label{open_cycle}
  \lstinputlisting[language=C]{yacc/open_cycle.c} %input de um ficheiro

  \subsubsection{Método auxiliar: int close\_cycle();}
  \label{close_cycle}
  \lstinputlisting[language=C]{yacc/close_cycle.c} %input de um ficheiro





  \chapter{ Testes às funcionalidades da Algebra}

  Realizada a tradução entre produções e código máquina, e exemplificada a forma de acesso aos dado na stack para os dados de maior complexidade, resta-nos passar à produção de testes a todas as funcionalidades descritas até ao momento. É também importante confirmar que as medidas de previsão de erros e garantia de estabilidade aos programas gerados funcionam correctamente.\par 
  Serão apresentados um conjunto de testes mais complexos(programas-fonte diversos e respectivo código produzido), que tentam testar de uma forma mais alargadas as funcionalidades da Algebra, sendo estes:
  \begin{itemize}
  \item Lidos 3 números, escrever o maior deles.
  \item Ler N (valor dado) números e calcular e imprimir o seu somatório.
  \item Contar e imprimir os números pares de uma sequência de N números dados.
  \item Ler e armazenar os elementos de um vetor de comprimento N, 
  imprimido os valores por ordem crescente após fazer a ordenação do array por trocas diretas.
  \item Ler e armazenar os elementos de uma matriz NxM, calculando e imprimindo de seguida a média e máximo dessa matriz.
  \item Invocar e usar num programa  uma função.
  \item Testar o aninhamento de condicionais
  \end{itemize} 

  Incluiremos ainda 3 testes à capacidade de deteção de erros, sendo estes:

  \begin{itemize}
  \item Impressão de uma variável não declarada.
  \item Re-declaração de uma variável.
  \item Erro sintático.
  \end{itemize} 

  \newpage
  \section{ Testes às funcionalidades da Algebra}

  \subsection{lidos 3 números, escrever o maior deles}
  \begin{multicols*}{2}
  \raggedcolumns
  \subsubsection{Código em linguagem de alto nível \textbf{\textit{Algebra}}}
  \lstinputlisting[language=C]{examples_algebra/3_numeros.txt} %input de um ficheiro
  \vfill
  \columnbreak
  \subsubsection{Código em \textbf{\textit{Assembly}} da Máquina Virtual VM }
  \lstinputlisting[language=C]{examples_vm/3_numeros.vm} %input de um ficheiro
  \end{multicols}
  \newpage

  \subsubsection{Exemplo de output da Máquina Virtual VM}
  \begin{figure}[H]
  \centering
  \includegraphics[width=1\columnwidth]{PNG/3_numeros.png}
  \caption{Exemplo de output da Máquina Virtual VM, para o teste: "lidos 3 números, escrever o maior deles"}
  \label{fig:teste1}
  \end{figure}
  \newpage


  \subsection{ler N (valor dado) números e calcular e imprimir o seu somatório}
  \begin{multicols*}{2}
  \raggedcolumns
  \subsubsection{Código em linguagem de alto nível \textbf{\textit{Algebra}}}
  \lstinputlisting[language=C]{examples_algebra/somatorio.txt} %input de um ficheiro
  \vfill
  \columnbreak
  \subsubsection{Código em \textbf{\textit{Assembly}} da Máquina Virtual VM }
  \lstinputlisting[language=C]{examples_vm/somatorio.vm} %input de um ficheiro
  \end{multicols}
  \newpage

  \subsubsection{Exemplo de output da Máquina Virtual VM}
  \begin{figure}[H]
  \centering
  \includegraphics[width=1\columnwidth]{PNG/somatorio.png}
  \caption{Exemplo de output da Máquina Virtual VM, para o teste: "ler N (valor dado) números e calcular e imprimir o seu somatório"}
  \label{fig:teste2}
  \end{figure}
  \newpage



  \subsection{Contar e imprimir os números pares de uma sequência de N números dados}
  \begin{multicols*}{2}
  \raggedcolumns
  \subsubsection{Código em linguagem de alto nível \textbf{\textit{Algebra}}}
  \lstinputlisting[language=C]{examples_algebra/sequencia.txt} %input de um ficheiro
  \vfill
  \columnbreak
  \subsubsection{Código em \textbf{\textit{Assembly}} da Máquina Virtual VM }
  \lstinputlisting[language=C]{examples_vm/sequencia.vm} %input de um ficheiro
  \end{multicols}
  \newpage

  \subsubsection{Exemplo de output da Máquina Virtual VM}
  \begin{figure}[H]
  \centering
  \includegraphics[width=1\columnwidth]{PNG/sequencia.png}
  \caption{Exemplo de output da Máquina Virtual VM, para o teste: "Contar e imprimir os números pares de uma sequência de N números dados"}
  \label{fig:teste3}
  \end{figure}
  \newpage




  \subsection{Ler e armazenar os elementos de um vetor de comprimento N
    imprimido os valores por ordem crescente após fazer a ordenação do array por trocas diretas}
    \begin{multicols*}{2}
    \raggedcolumns
    \subsubsection{Código em linguagem de alto nível \textbf{\textit{Algebra}}}
    \lstinputlisting[language=C]{examples_algebra/array_crescente.txt} %input de um ficheiro
    \vfill
    \columnbreak
    \subsubsection{Código em \textbf{\textit{Assembly}} da Máquina Virtual VM }
    \lstinputlisting[language=C]{examples_vm/array_crescente.vm} %input de um ficheiro
    \end{multicols}
    \newpage

    \subsubsection{Exemplo de output da Máquina Virtual VM}

    \begin{figure}[H]
    \centering
    \includegraphics[width=1\columnwidth]{PNG/array_crescente.png}
    \caption{Exemplo de output da Máquina Virtual VM, para o teste: "Ler e armazenar os elementos de um vetor de comprimento N
      imprimido os valores por ordem crescente após fazer a ordenação do array por trocas diretas"}
      \label{fig:teste4}
      \end{figure}
      \newpage




      \subsection{Ler e armazenar os elementos de uma matriz NxM, calculando e imprimindo de seguida a média e máximo dessa matriz}
      \begin{multicols*}{2}
      \raggedcolumns
      \subsubsection{Código em linguagem de alto nível \textbf{\textit{Algebra}}}
      \lstinputlisting[language=C]{examples_algebra/media_maximo_matriz.txt} %input de um ficheiro
      \vfill
      \columnbreak
      \subsubsection{Código em \textbf{\textit{Assembly}} da Máquina Virtual VM }
      \lstinputlisting[language=C]{examples_vm/media_maximo_matriz.vm} %input de um ficheiro
      \end{multicols}
      \newpage

      \subsubsection{Exemplo de output da Máquina Virtual VM}
      \begin{figure}[H]
      \centering
      \includegraphics[width=1\columnwidth]{PNG/media_maximo_matriz.png}
      \caption{Exemplo de output da Máquina Virtual VM, para o teste: "Ler e armazenar os elementos de uma matriz NxM, calculando e imprimindo de seguida a média e máximo dessa matriz"}
      \label{fig:teste5}
      \end{figure}
      \newpage




      \subsection{Invocar e usar num programa uma função}
      \begin{multicols*}{2}
      \raggedcolumns
      \subsubsection{Código em linguagem de alto nível \textbf{\textit{Algebra}}}
      \lstinputlisting[language=C]{examples_algebra/funcao.txt} %input de um ficheiro
      \vfill
      \columnbreak
      \subsubsection{Código em \textbf{\textit{Assembly}} da Máquina Virtual VM }
      \lstinputlisting[language=C]{examples_vm/funcao.vm} %input de um ficheiro
      \end{multicols}
      \newpage

      \subsubsection{Exemplo de output da Máquina Virtual VM}
      \begin{figure}[H]
      \centering
      \includegraphics[width=1\columnwidth]{PNG/funcao.png}
      \caption{Exemplo de output da Máquina Virtual VM, para o teste: "Invocar e usar num programa uma função"}
      \label{fig:teste6}
      \end{figure}
      \newpage


      \subsection{Testar o aninhamento de condicionais}
      \begin{multicols*}{2}
      \raggedcolumns
      \subsubsection{Código em linguagem de alto nível \textbf{\textit{Algebra}}}
      \lstinputlisting[language=C]{examples_algebra/teste_ifs.txt} %input de um ficheiro
      \vfill
      \columnbreak
      \subsubsection{Código em \textbf{\textit{Assembly}} da Máquina Virtual VM }
      \lstinputlisting[language=C]{examples_vm/teste_ifs.vm} %input de um ficheiro
      \end{multicols}
      \newpage

      \subsubsection{Exemplo de output da Máquina Virtual VM}
      \begin{figure}[H]
      \centering
      \includegraphics[width=1\columnwidth]{PNG/teste_ifs.png}
      \caption{Exemplo de output da Máquina Virtual VM, para o teste: "Testar o aninhamento de condicionais"}
      \label{fig:teste7}
      \end{figure}
      \newpage



      \section{Testes às capacidades de deteção de erros}


      \subsection{Impressão de uma variável não declarada}
      \begin{multicols*}{2}
      \raggedcolumns
      \subsubsection{Código em linguagem de alto nível \textbf{\textit{Algebra}}}
      \lstinputlisting[language=C]{examples_algebra/variavel_nao_declarada.txt} %input de um ficheiro
      \vfill
      \columnbreak
      \subsubsection{Código em \textbf{\textit{Assembly}} da Máquina Virtual VM }
      \lstinputlisting[language=C]{examples_vm/variavel_nao_declarada.vm} %input de um ficheiro
      \end{multicols}
      \newpage

      \subsubsection{Exemplo de output da Máquina Virtual VM}
      \begin{figure}[H]
      \centering
      \includegraphics[width=1\columnwidth]{PNG/variavel_nao_declarada.png}
      \caption{Exemplo de output da Máquina Virtual VM, para o teste: "Impressão de uma variável não declarada"}
      \label{fig:teste8}
      \end{figure}
      \newpage



      \subsection{Re-declaração de uma variável}
      \begin{multicols*}{2}
      \raggedcolumns
      \subsubsection{Código em linguagem de alto nível \textbf{\textit{Algebra}}}
      \lstinputlisting[language=C]{examples_algebra/variavel_re_declarada.txt} %input de um ficheiro
      \vfill
      \columnbreak
      \subsubsection{Código em \textbf{\textit{Assembly}} da Máquina Virtual VM }
      \lstinputlisting[language=C]{examples_vm/variavel_re_declarada.vm} %input de um ficheiro
      \end{multicols}
      \newpage

      \subsubsection{Exemplo de output da Máquina Virtual VM}
      \begin{figure}[H]
      \centering
      \includegraphics[width=1\columnwidth]{PNG/variavel_re_declarada.png}
      \caption{Exemplo de output da Máquina Virtual VM, para o teste: "Re-declaração de uma variável"}
      \label{fig:teste9}
      \end{figure}
      \newpage


      \subsection{Erro sintático}
      \begin{multicols*}{2}
      \raggedcolumns
      \subsubsection{Código em linguagem de alto nível \textbf{\textit{Algebra}}}
      \lstinputlisting[language=C]{examples_algebra/erro_sintatico.txt} %input de um ficheiro
      \vfill
      \columnbreak
      \subsubsection{Código em \textbf{\textit{Assembly}} da Máquina Virtual VM }
      \lstinputlisting[language=C]{examples_vm/erro_sintatico.vm} %input de um ficheiro
      \end{multicols}
      \newpage

      \subsubsection{Exemplo de output da Máquina Virtual VM}
      \begin{figure}[H]
      \centering
      \includegraphics[width=1\columnwidth]{PNG/erro_sintatico.png}
      \caption{Exemplo de output da Máquina Virtual VM, para o teste: Erro sintático}
      \label{fig:teste10}
      \end{figure}
      \newpage



      \chapter{Conclusão}
      \label{concl}

      Relativamente ao estado final do projecto acreditamos que foram cumpridos todos os requisitos, sendo que a compreensão da máquina virtual e o seu funcionamento pode ser considerada a parte mais penosa do mesmo. Acreditamos que a presença de instruções adicionais na mesma iria facilitar e permitir o desenvolvimento de outras funcionalidades (mais avançadas) no programa.  Em adição, achamos que noção de stack e frame pointer para chamadas de funções dentro do programa  principal ainda precisa de ser mais trabalhada. \par 
      Foi ainda tido em conta a possiblidade de existência de erros de leitura e de compilação o que tornou o compilador mais robusto. No entanto deveria ser dado mais ênfase ao mesmo. \par 
      Relativamente às estruturas de dados utilizados, acreditamos que as mesmas são de grande simplicidade quando comparadas com o trabalho prático -- uma vez que o objectivo deste trabalho era traduzir operações complexas em código máquina -- não faria de todo sentido guardar estado ou tentar "aldrabar" de qualquer forma os limites da máquina virtual.\par 
      O balanço  do trabalho prático é extremamente, pois, apesar de ser extremamente "time consuming" permite  aplicação de muito do conhecimento retido da Unidade Curricular de Processamento de Linguagens, no que da análise de dados, análise léxica, parsing, e GIC's diz respeito.
      \end{document}
