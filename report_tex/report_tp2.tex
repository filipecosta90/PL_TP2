%
% Layout retirado de http://www.di.uminho.pt/~prh/curplc09.html#notas
%

\documentclass{report}

\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}

\usepackage[portuges]{babel}
\usepackage[latin1]{inputenc}

\usepackage{url}

\usepackage{listings}

\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\lstset{
  keepspaces=true,  
    tabsize=2,
    basicstyle=\footnotesize,
    numbers=left,
    numberstyle=\tiny,
    numbersep=5pt,
    breaklines=true,
    frame=tB,
   % mathescape=true
   escapeinside={(*@}{@*)}
}

%%                                                       -*- LaTeX -*-
%% Language definition of Yacc/Bison for listings package
%%

%% Yacc
\lstdefinelanguage[]{Yacc}%
{otherkeywords=%
  {\%left,
    \%nonassoc,\%prec,\%right,
    \%start,\%token,\%type,\%union,
    \%\%,\%\{,\%\},|,:,
    \$\$,\$1,\$2,\$3,\$4,\$5,\$6,\$7,\$8,\$9
  },%
  keywords={\%seeREADME},%
    morecomment=[n]{/*}{*/},%
    morestring=[b]{"},%
    sensitive=true
}[keywords,comments,strings]%


%% Yacc: Bison

%% Listings does not support ``moreotherkeywords'', so we cannot
%% simply inherit.  To bad for code duplication.
\lstdefinelanguage[Bison]{Yacc}%
{otherkeywords=%
  {\%binary,\%debug,\%default-prec,\%define,\%defines,\%destructor,
    \%dprec,\%error-verbose,\%expect,\%expect-rr,\%file-prefix,
    \%fixed-output-files,\%initial-action,\%glr-parser,
    \%language,\%left,
    \%lex-param,\%locations,\%merge,\%name-prefix,\%no-default-prec,
    \%no-lines,\%nonassoc,\%nondeterministic-parser,\%nterm,\%output,
    \%parse-param,\%prec,\%printer,\%pure-parser,\%right,\%skeleton,
    \%start,\%term,\%token,\%token-table,\%type,\%union,\%verbose,\%yacc,
    \%\%,\%\{,\%\},|,:,
    \$\$,\$1,\$2,\$3,\$4,\$5,\$6,\$7,\$8,\$9,
    @\$,@1,@2,@3,@4,@5,@6,@7,@8,@9
  },%
  keywords={\%seeREADME},%
    morecomment=[n]{/*}{*/},%
    morecomment=[s]{//},%
    morestring=[b]{"},%
    sensitive=true
}[keywords,comments,strings]%

\lstdefinelanguage{Bison}[Bison]{Yacc}{}


\usepackage{fix-cm}

\usepackage{listings}






\usepackage{xspace}
\usepackage{graphicx}
\usepackage{float}

\parindent=0pt
\parskip=2pt

\setlength{\oddsidemargin}{-1cm}
\setlength{\textwidth}{18cm}
\setlength{\headsep}{-1cm}
\setlength{\textheight}{23cm}

\def\darius{\textsf{Darius}\xspace}
\def\java{\texttt{Java}\xspace}
\def\pe{\emph{Publicação Eletrónica}\xspace}


\title{Processamento de Linguagens (3º ano de Curso)\\ \textbf{Trabalho Prático N 2}\\ Relatório de Desenvolvimento}
\author{Filipe Costa Oliveira\\ a57816  }
\date{\today}

\begin{document}

\maketitle

\newpage

\tableofcontents

\chapter{Introdução} \label{intro}

O presente trabalho prático foca-se no desenvolvimento de  um compilador, que tem como fonte uma linguagem de alto nível (também esta desenvolvida especificamente para este trabalho prático) , gerando código para uma máquina de stack virtual. \par 
Um compilador comum divide o processo de tradução em várias fases. Para o propósito específico desta unidade curricular iremos focar-nos nas seguintes:
\begin{itemize}
\item 1ª Fase de tradução -- Análise Léxica, que agrupa sequências de caracteres em tokens. Recorreremos nesta fase à definição das expressões regulares que permitem definir os tokens.
\item 2ª Fase de tradução --  Reconhecimento(Parsing) da estrutura gramatical do programa, através do agrupamento dos tokens em produções. Recorreremos à definição de uma gramática independente de contexto por forma a definir as estruturas de programa válidas a reconhecer pelo parser. Denote que juntamente com o parsing é realizada a análise semântica, assim como a geração de código associando regras às produções anteriormente descritas.
\end{itemize} 
Começaremos portanto por definir uma linguagem de programação imperativa simples, que chamaremos Algebra. A Algebra permitirá:
\begin{itemize}
\item declarar e manusear variáveis atómicas do tipo inteiro, com os quais se podem realizar as habituais operações
aritméticas, relacionais e lógicas.
\item declarar e manusear variáveis estruturadas do tipo array (a 1 ou 2 dimensões) de inteiros, em relação aos quais  é apenas permitida a operação de indexação. Aos arrays de duas dimensões, por se tratar de uma linguagem algébrica, chamaremos matrizes, dada a fácil associação a este tipo de variável à sua definição análoga da álgebra linear.
\item efetuar instruções algorítmicas básicas como a atribuição de expressões a variáveis.
\item ler do standard input e escrever no standard output.
\item  efetuar instruções para controlo do fluxo de execução -- condicional e cíclica -- que possam ser aninhadas.
\item definir e invocar subprogramas sem parâmetros mas que possam retornar um resultado atómico.
\end{itemize} 

Na nossa linguagem de programação por questões de estruturação e percepção, teremos como premissa que as varíaveis deverão ser declaradas no início do programa, não podendo haver re-declarações, nem utilizações sem declaração prévia. Não será permitida a declaração e associação de um valor inteiro na mesma instrução. Achamos essa solução pouco elegante. Assim, todas as variáveis terão o valor zero após a declaração.\par 

Será desenvolvido portanto o compilador para a Algebra, com base na GIC criada acima e recurso ao Gerador Yacc/ Flex.
O compilador de Algebra irá gerar pseudo-código, Assembly da Máquina Virtual VM cuja documentação completa está disponibilizada em anexo.\par
Por forma a facilitar e validar o trabalho, à medida que as funcionalidades forem descritas serão apensados  exemplos ilustrativos. \par 
Por fim, serão apresentados um conjunto de testes mais complexos(programas-fonte diversos e respectivo código produzido), que tentam testar de uma forma mais alargadas as funcionalidades da Algebra, sendo estes:
\begin{itemize}
\item lidos 3 números, escrever o maior deles.
\item ler N (valor dado) números e calcular e imprimir o seu somatório.
\item contar e imprimir os números pares de uma sequência de N números dados.
\item ler e armazenar os elementos de um vetor de comprimento N, 
  imprimido os valores por ordem crescente após fazer a ordenação do array por trocas diretas.
  \item ler e armazenar os elementos de uma matriz NxM, calculando e imprimindo de seguida a média e máximo dessa matriz.
  \item  invocar e usar num programa  uma função.
  \end{itemize} 


  \chapter{Concepção da Linguagem Algebra}
  \label{concepcao}

  \section{Concepção/desenho da Resolução}


  Comecemos por descrever as funcionalidades da linguagem Algebra. Tal como descrito anteriormente a Algebra permitirá:
  \begin{itemize}

  \item declarar e manusear variáveis atómicas do tipo inteiro, com os quais se podem realizar as habituais operações aritméticas, relacionais e lógicas.
  \item declarar e manusear variáveis estruturadas do tipo array (a 1 ou 2 dimensões) de inteiros, em relação aos quais  é apenas permitida a operação de indexação. Aos arrays de duas dimensões, por se tratar de uma linguagem algébrica, chamaremos matrizes, dada a fácil associação a este tipo de variável à sua definição análoga da álgebra linear.
  \item efetuar instruções algorítmicas básicas como a atribuição de expressões a variáveis.
  \item ler do standard input e escrever no standard output.
  \item  efetuar instruções para controlo do fluxo de execução -- condicional e cíclica -- que possam ser aninhadas.
  \item definir e invocar subprogramas sem parâmetros mas que possam retornar um resultado atómico.

  \end{itemize} 

  \subsection{Uma introdução às variáveis}
  Temos então que as variáveis poderão ser de 3 tipos: inteiros simples, arrays de inteiros, e matrizes de inteiros. Dessa premissa sabemos à partida que o código gerado para a nossa máquina virtual terá que suportar o tipo de variável inteiro. Sabemos ainda que aos tipos de dados mais complexos (arrays e matrizes) apenas é permita a realização de operações de indexação. \par
  Na nossa linguagem de programação por questões de estruturação e percepção, teremos como premissa que as variáveis deverão ser declaradas no início do programa, não podendo haver re-declarações, nem utilizações sem declaração prévia. Não será permitida a declaração e associação de um valor inteiro na mesma instrução(à lá C). Achamos essa solução pouco elegante. 
  Assim, todas as variáveis terão o valor zero após a declaração.\par
  Podemos então aceitar como exemplo as declarações do tipo:

  \lstinputlisting[language=C]{exemplos/1_variaveis.c} %input de um ficheiro

  Dado que toda a porção de código de alto nível julgamos essencial a possibilidade de existência de comentários. Atente no exemplo anterior agora com comentários que facilitam a percepção:

  \lstinputlisting[language=C]{exemplos/2_variaveis.c} %input de um ficheiro


  Tal como poderá confirmar pela última declaração do exemplo anterior a declaração do tamanho das matrizes é feita da seguinte forma: \textbf{ nome\_variavel[nºlinhas,nºcolunas]}. \par 
  A forma de armazenamento e acesso às variáveis será posteriormente discutida nas secções seguintes deste relatório. Neste momento temos especial interesse na especificação da estrutura correcta de programas da nossa linguagem.

  \subsubsection{Expressões Regulares e acções resultantes}
  \label{flex1}
  Podemos desde já enumerar as expressões regulares necessárias à produção dos tokens que permitam à GIC o agrupamento dos tokens em produções:

  \lstinputlisting[language=Yacc]{flex/flex_1_variaveis.l} %input de um ficheiro

  Como é perceptível pela expressão regular correspondente, vulgo \lstinline${letter}({letter}|{digit}|\_)*$, as variáveis do tipo inteiro terão sempre de ser iniciadas por uma letra (maiúscula ou minúscula), sendo que como segundo caracter poderão ter um número, letra, ou \_.\par 

  \subsubsection{Produções da GIC}
  \label{yacc1}
  Com os tokens produzidos pelo parser, podemos iniciar a definição da gramática independente de contexto, resultando nas seguintes produções:

  \lstinputlisting[language=Yacc]{yacc/yacc_1_variaveis.y} %input de um ficheiro


  \subsection{Uma introdução às instruções}
  \label{introducao_instrucoes}

  Da necessidade de realizar operações aritméticas, relacionais e lógicas sobre as variáveis do tipo inteiro atómicas, assim como da necessidade de realizar instruções algorítmicas básicas como a atribuição de expressões a variáveis, surgem as \textbf{instruções} na nossa linguagem \textbf{\textit{Algebra}}.\par 
  Consideramos que qualquer que seja a operação a ser realizada, o seu resultado terá que ser sempre atribuído a alguma variável. \par 
  Podemos desde já enumerar os tipos de operações permitidas na nossa linguagem, associando também o operador utilizador para representar as mesmas:
  \begin{itemize}
  \item Aritmética
  \begin{itemize}
  \item Adição : '+'
  \item Subtração : '-'
  \item Multiplicação inteira : '*'
  \item Divisão Inteira : '/'
  \item Resto da Divisão Inteira : '%'
  \end{itemize}
  \item Relaccional
  \begin{itemize}
  \item Igualdade : '=''='
  \item Diferença : '!''='
  \item Superioridade : '$>$'
  \item Superioridade ou Igualdade : '$>$''='
  \item Inferioridade : '$<$'
  \item Inferioridade ou Igualdade : '$<$''='
  \end{itemize}
  \item Lógica
  \begin{itemize}
  \item Negação Lógica : '!'
  \item OR Lógico : '$|$''$|$'
  \item AND Lógico : '\&\&'
  \end{itemize}
  \end{itemize}

  Podemos então aceitar como exemplo de input válido o seguinte código:

  \lstinputlisting[language=C]{exemplos/3_instrucoes.c} %input de um ficheiro

  Como poderá constatar pelas linhas 7 e 8, e tal como é requerido já será possível realizar operações de atribuição. \par 

  \subsubsection{Expressões Regulares e acções resultantes}
  Relativamente às expressões regulares necessárias para proceder correctamente ao parsing não é necessário alterar os ficheiro Flex presente na seção \ref{flex1}, uma vez que a expressão regular 
  \lstinline$[\%\,\{\}\+\-\(\)\=\>\<\!\;\/\*\[\]\|\&\_]$ já engloba todos os símbolos necessárias até à fase actual.

  \subsubsection{Produções da GIC}
  \label{yacc2}
  Tomando por base o ficheiro Yacc presente na seção \ref{yacc1}, podemos proceder à adição de produções por forma a reconhecer as estruturas de programa válidas até ao momento.

  \lstinputlisting[language=Yacc]{yacc/yacc_2_instrucoes.y} %input de um ficheiro

  As produções relativas às expressões lógicas e relacionais terão especial importância na adição da capacidade de inclusão de instruções para controlo do fluxo de execução -- condicional e cíclica -- que possam ser aninhadas, na nossa linguagem \textbf{\textit{Algebra}}, que passaremos de seguida e especificar.

  \subsection{Uma introdução às instruções condicionais e cíclicas}
  \label{introducao_condicionais}

  \subsubsection{Instruções condicionais}
  Por forma à \textbf{\textit{Algebra}} ter utilidade real, é necessária a inclusão de instruções que permitam mudar o fluxo de execução. Necessitamos portanto de incluir a possibilidade de declarar instruções condicionais na nossa linguagem. \par 
  Para criarmos uma estrutura condicional, deveremos recorrer a expressões do tipo: 
  \begin{center}
  \textbf{if} ( Expressão Lógica )\par  \textbf{then}  [\{Instruções\}$|$Instrução] \par \textbf{else} [\{Instruções\}$|$Instrução$|$/*empty*/]\par 
  \end{center}

  Pela análise do esquema anterior sabemos que o bloco de código \textbf{else} [\{Instruções\}$|$Instrução$|$/*empty*/] é opcional, sendo que, em caso de os fluxos de execução representarem apenas uma instrução na nossa linguagem \textbf{\textit{Algebra}} não existe a necessidade de inclusão de parêntesis entre os diferentes fluxos.\par 
  Tal como requerido, deverá ser também possível o aninhamento de instruções condicionais.\par 
  Podemos então aceitar como exemplo de input válido o seguinte código:
  \lstinputlisting[language=C]{exemplos/4_condicional.c} %input de um ficheiro

  \subsubsection{Instruções cíclicas}

  Uma instrução cíclica irá permitir ao programador executar um determinado bloco de código um determinado número de vezes, de acordo com uma condição lógica.\par 
  Para criarmos uma estrutura cíclica, deveremos recorrer a expressões do tipo: 
  \begin{center}
  \textbf{do}   [\{Instruções\}$|$Instrução]\par 
  \textbf{while} ( Expressão Lógica )\par\par 
  \end{center}
  Pela análise do esquema anterior sabemos que em caso de o fluxo de execução representar apenas uma instrução na nossa linguagem \textbf{\textit{Algebra}} não existe a necessidade de inclusão de parêntesis entre as palavras reservadas  \textbf{do} e  \textbf{while}.\par 

  Tal como requerido, deverá ser também possível o aninhamento de instruções condicionais.\par 
  Podemos então aceitar como exemplo de input válido o seguinte código:
  \lstinputlisting[language=C]{exemplos/5_ciclo.c} %input de um ficheiro

  \subsubsection{Expressões Regulares e acções resultantes}
  \label{flex3}

  Tomando por base o ficheiro Flex  presente na seção \ref{flex1}, podemos proceder à adição de expressões regulares por forma a produzir os tokens necessários para o correcto reconhecimento pela GIC.
  \lstinputlisting[language=Yacc]{flex/flex_3_condicionais.y} %input de um ficheiro


  \subsubsection{Produções da GIC}
  \label{yacc3}
  Tomando por base o ficheiro Yacc presente na seção \ref{yacc1}, podemos proceder à adição de produções por forma a reconhecer as estruturas de programa válidas até ao momento.

  \lstinputlisting[language=Yacc]{yacc/yacc_3_condicionais.y} %input de um ficheiro


  \subsection{Uma introdução às instruções de leitura do  standard input e escrita no standard output}
  \label{introducao_input_output}


  \subsubsection{Instruções de leitura do standard input}
  \label{introducao_input}
  Por forma à \textbf{\textit{Algebra}} poder efectuar operações de leitura do standard input, é necessária a inclusão de instruções que permitam a leitura de inteiros, e atribuição do valor inteiro a uma variável. \par Consideramos que só fará sentido ler dados do standard input se os mesmos foram atribuídos. "Ler por Ler" do Standard Input não representa nenhuma mais valia para a linguagem. \par 
  Podemos então aceitar como exemplo de input válido o seguinte código:

  \lstinputlisting[language=C]{exemplos/6_input.c} %input de um ficheiro

  \subsubsection{Instruções de escrita no standard output}
  \label{introducao_output}
  Uma instrução de escrita no standard output permitirá ao programador imprimir o valor de variáveis do tipo inteiro atómicas, variáveis do tipo array e matriz, assim como de valores inteiros directamente, e ainda de variáveis do tipo string, vulgo uma sequência de caracteres iniciada por " e terminada por ". \par 
  Denote que na nossa linguagem não é permitido realizar operações sobre strings (como concatenação ou comparação), apenas será permitir escrever as mesmas no standard output.\par
  Ora, retomando o exemplo da seção \ref{introducao_input}, podemos agora torná-lo mais completo com adição de instruções de escrita no standard input.
  \lstinputlisting[language=C]{exemplos/7_output.c} %input de um ficheiro

  \subsubsection{Expressões Regulares e acções resultantes}
  \label{flex4}

  Tomando por base o ficheiro Flex  presente na seção \ref{flex3}, podemos proceder à adição de expressões regulares por forma a produzir os tokens necessários para o correcto reconhecimento pela GIC.
  \lstinputlisting[language=Yacc]{flex/flex_4_input_output.l} %input de um ficheiro


  \subsubsection{Produções da GIC}
  \label{yacc4}
  Tomando por base o ficheiro Yacc presente na seção \ref{yacc3}, podemos proceder à adição de produções por forma a reconhecer as estruturas de programa válidas até ao momento.

  \lstinputlisting[language=Yacc]{yacc/yacc_4_input_output.y} %input de um ficheiro

  Possuímos neste momento todas as ferramentas necessárias para a escrita de programas na linguagem de alto nível \textbf{\textit{Algebra}} que recorram aos seguintes requisitos:

  \begin{itemize}
  \item declarar e manusear variáveis atómicas do tipo inteiro, com os quais se podem realizar as habituais operações aritméticas, relacionais e lógicas.
  \item declarar e manusear variáveis estruturadas do tipo array e matrizes de inteiros, em relação aos quais  é apenas permitida a operação de indexação. 
  \item efetuar instruções algorítmicas básicas como a atribuição de expressões a variáveis.
  \item ler do standard input e escrever no standard output.
  \item  efetuar instruções para controlo do fluxo de execução -- condicional e cíclica -- que possam ser aninhadas.
  \end{itemize} 

  Resta-nos passar à adição de funcionalidades que permitam definir e invocar subprogramas sem parâmetros mas que possam retornar um resultado atómico.


  \subsection{Uma introdução aos subprogramas}
  \label{introducao_subprogramas}
  Por  forma a definir e invocar subprogramas sem parâmetros mas que possam retornar um resultado atómico, é necessária a inclusão de instruções que permitam a declaração de blocos de código que apenas serão executados quando invocada a função onde estes estão inscritos.\par 
  Ora, mantendo a premissa de estruturação e percepção já existente, decidimos que as declarações de funções terão de ocorrer depois das declarações de variáveis, e antes do início do programa principal. \par 
  Não será permitida redeclaração de funções, nem utilização de funções no programa principal sem declaração prévia.  \par 
  Entendemos que especificamente para a na nossa linguagem de alto nível, todos os subprogramas retornam sempre uma variável com valor inteiro. 
  Tendo em conta o descrito anteriormente, para criarmos um subprograma, deveremos recorrer a instruções do tipo: 
  \begin{center}
  \textbf{declare} nome\_função ( ) \{ \par  Instruções \par  \textbf{return} valor\_inteiro ; \}
  \end{center}

  Para invocarmos um subprograma, deveremos a instruções do tipo:

  \begin{center}
  variável = \textbf{call} nome\_função ( ) ; 
  \end{center}


  \subsubsection{Expressões Regulares e acções resultantes}
  \label{flex5}

  Tomando por base o ficheiro Flex  presente na seção \ref{flex4}, podemos proceder à adição de expressões regulares por forma a produzir os tokens necessários para o correcto reconhecimento pela GIC.
  \lstinputlisting[language=Yacc]{flex/flex_5_funcoes.l} %input de um ficheiro

  \subsubsection{Produções da GIC}
  \label{yacc5}
  Tomando por base o ficheiro Yacc presente na seção \ref{yacc4}, podemos proceder à adição de produções por forma a reconhecer as estruturas de programa válidas até ao momento.

  \lstinputlisting[language=Yacc]{yacc/yacc_5_funcoes.y} %input de um ficheiro

  Concluímos neste momento o estudo sobre a linguagem \textbf{\textit{Algebra}}, e consequentemente a gramática independente de contexto e analisador léxico. 

  \chapter{Introdução à Máquina Virtual}

  Concluída a gramática independente de contexto e o analisador léxico, o próximo passo será dar a conhecer a máquina para a qual pretendemos gera código máquina. Trata-se duma maquina de pilhas, composta duma pilha de execução, duma pilha de chamadas, duma zona de código, de duas heaps e de
  quatro registos.\par 

  A pilha de execução contém valores, que podem ser inteiros, reais ou endereços.\par
  As duas heaps contêm, respectivamente, cadeias de caracteres (strings) e blocos estruturados.\par
  Cada um destes tipos de dados é referenciado por endereços. Cada bloco estruturado contem um certo número de valores (do mesmo tipo dos valores que se podem encontrar na pilha).
  Um endereço pode apontar para quatro tipos de informação: para código, para a pilha, para um bloco estruturado ou para uma string.
  Três registos permitam o acesso a diferentes partes da pilha:
  \begin{itemize}
  \item  O registo sp (stack pointer) aponta para o topo corrente da pilha. Ele aponta para a primeira célula livre da pilha.
  \item  O registo fp (frame pointer) aponta para o endereço de base das variáveis locais.
  \item  O registo gp contem o endereço de base das variáveis globais.
  \end{itemize}
  A máquina possui um registo pc que aponta para a instrução corrente (da zona de código) por executar.\par 
  A pilha de chamada permite guardar as chamadas: contém pares de apontadores (i, f). O endereço i guarda o registo de instrução pc e f o registo fp.

  \section{As instruções}

  As instruções são designadas por um nome e podem aceitar um ou dois parâmetros. Estes podem ser:
  \begin{itemize}
  \item constantes inteiras.
  \item  constantes reais.
  \item cadeias de caracteres delimitadas por aspas. Estas cadeias de caracteres seguem as mesmas regras de formatação que as cadeias da linguagem C 
  (em particular no que diz respeito aos caracteres especiais como $\backslash $ ", $\backslash $ n ou $\backslash $$\backslash $ ).
  \item uma etiqueta simbólica designando uma zona no código.
  \end{itemize}

  Para o caso específico da linguagem de alto nível que nos propomos a desenvolver temos especial interesse em instruções que lidem com:

  \begin{itemize}
  \item constantes inteiras.
\item cadeias de caracteres delimitadas por aspas. (apenas necessárias para as operações de leitura e escrita)
  \item uma etiqueta simbólica designando uma zona no código.
  \end{itemize}


  \subsection{Operações de base e assunções}
  Por forma a gerarmos correctamente código máquina devemos ter em consideração os seguintes pontos:

  \begin{itemize}

  \item   As operações aritméticas  envolvem os valores do topo e do sub-topo da pilha. \par 
  Neste caso quando a operação envolvida é executada, os dois argumentos são retiradas da pilha
(refira-se à secção das convenções para perceber o que é retirar valores da pilha) 
  e o resultado é então empilhado. \par 
  \item O resultado duma operação de comparação é um inteiro que vale 0 ou 1. 
  \item  O inteiro 0 representa o valor booleano falso enquanto o valor 1 representa o valor verdade.
  \end{itemize}

  De todas as operações disponíveis, apresentamos de seguida aquelas sobre as quais a GIC irá incluir na geração de código máquina. Atente na separação por tipo de operação:

  \subsubsection{Operações sobre inteiros}

  \begin{table}[H]
    \label{table:operacoes_inteiros}
\centering
  \begin{tabular}{ | L{2cm} | L{2cm} |  R{10cm} | }
  
  
  \hline
  Instrução & Argumentos & Descrição
  \\ \hline \hline

  ADD & & tira da pilha n e m que devem ser inteiros e empilha o resultado
  m + n
  \\ \hline 

  SUB & & tira da pilha n e m que devem ser inteiros e empilha o resultado
  m - n
  \\ \hline

  MUL & &  tira da pilha n e m que devem ser inteiros e empilha o resultado
  m $×$ n
  \\ \hline

  DIV & & tira da pilha n e m que devem ser inteiros e empilha o resultado
  m$/$n
  \\ \hline 

  MOD& &  tira da pilha n e m que devem ser inteiros e empilha o resultado
  m mod n
  \\ \hline 

  NOT& &  tira da pilha n que deve ser um inteiro e empilha o resultado n = 0
  \\ \hline 

  INF & & tira da pilha n e m que devem ser inteiros e empilha o resultado
  m $<$ n
  \\ \hline

  INFEQ & & tira da pilha n e m que devem ser inteiros e empilha o resultado
  m  $<=$n
  \\ \hline 

  SUP & & tira da pilha n e m que devem ser inteiros e empilha o resultado
  m $>$ n
  \\ \hline 

  SUPEQ & & tira da pilha n e m que devem ser inteiros e empilha o resultado
  m $>=$ n
  \\ \hline 
  \end{tabular}
  \end{table}

  \subsubsection{Operações sobre endereços}

  \begin{table}[H]
    \label{table:operacoes_enderecos}
\centering
  \begin{tabular}{ | L{2cm} | L{2cm} |  R{10cm} | }
  \hline
  Instrução & Argumentos & Descrição
  \\ \hline \hline
  PADD  & &  tira da pilha n que deve ser um inteiro e a que deve ser um endereço
  e empilha o endereço a + n
  \\ \hline 

  \end{tabular}
  \end{table}



  \subsubsection{Igualdade}

  \begin{table}[H]
    \label{table:igualdade}
\centering
  \begin{tabular}{ | L{2cm} | L{2cm} |  R{10cm} | }
  \hline
  Instrução & Argumentos & Descrição
  \\ \hline \hline

  EQUAL   & &  tira da pilha n seguido de m que devem ser do mesmo tipo e empilha
  o resultado de n = m
  \\ \hline 

  \end{tabular}
  \end{table}




  \subsubsection{Conversões}


 \begin{table}[H]
    \label{table:conversoes}
\centering
  \begin{tabular}{ | L{2cm} | L{2cm} |  R{10cm} | }
  \hline
  Instrução & Argumentos & Descrição
  \\ \hline \hline
  
  
  ATOI   &   & retira da pilha o endereço duma string e empilha a sua conversão
  em inteiro. Tal falha quando a string não representa um inteiro.
  \\ \hline 

  \end{tabular}
  \end{table}



  \subsubsection{Manipular dados}

 \begin{table}[H]
    \label{table:manipular_dados}
\centering
  \begin{tabular}{ | L{2cm} | L{2cm} |  R{10cm} | }
  \hline
  Instrução & Argumentos & Descrição
  \\ \hline \hline

  PUSHI & n inteiro   &  empilha n
  \\ \hline 
  PUSHN  & n inteiro   &  empilha n vezes o valor inteiro 0

  \\ \hline 
  PUSHS & n string   &  arquiva n na zona das strings e empilha o endereço
  \\ \hline 
  PUSHG & n inteiro   &  empilha o valor localizado em gp[n]
  \\ \hline 
  PUSHGP   & &  empilha o valor do registo gp
  \\ \hline 
  LOAD  & n inteiro   &  retira da pilha um endereço a e empilha o valor na pilha ou
  no heap (dependendo do tipo de a) em a[n]
  \\ \hline 
  LOADN  &  &  retira da pilha um inteiro n, um endereço a e empilha o valor
  na pilha ou no heap (dependendo do tipo de a) em a[n]
  \\ \hline 
  STOREG & n inteiro   &  retira um valor da pilha e arquiva-a na pilha em gp[n]
  \\ \hline 
  STORE & n inteiro   &  retira da pilha um valor v e um endereço a, arquiva v
em a[n]na pilha ou na heap (dependendo do tipo de a)
  \\ \hline 
  STOREN   & &  retira da pilha um valor v, um inteiro n e um endereço
  a, arquiva v no endereço a[n] na pilha ou na heap
  \\ \hline 

  \end{tabular}
  \end{table}

  \subsubsection{Input-Output}

  \begin{table}[H]
    \label{table:input}
\centering
  \begin{tabular}{ | L{2cm} | L{2cm} |  R{10cm} | }
  \hline
  Instrução & Argumentos & Descrição
  \\ \hline \hline
  WRITEI   & &  retira um inteiro da pilha e imprime o valor na saída standard
  \\ \hline 
  WRITES  &  &  retira um endereço de uma string da pilha e imprime a string correspondente
  na saída standard
    \\ \hline 
  READ  &  &  lê uma string do teclado (concluída por um "$\backslash$n") e arquiva esta
  string (sem o "$\backslash$n") na heap e coloca (empilha) o endereço na pilha..
  \\ \hline 
  \end{tabular}
  \end{table}

  \subsubsection{Operações de controlo}

 \begin{table}[H]
    \label{table:controlo}
\centering
  \begin{tabular}{ | L{2cm} | L{2cm} |  R{10cm} | }
  \hline
  Instrução & Argumentos & Descrição
  \\ \hline \hline

  JUMP &  label etiqueta &  atribui ao registo pc o endereço no código que corresponde a
  label   (pode ser um inteiro ou um valor simbólico).
  \\ \hline 
  JZ & label etiqueta &  retira da pilha um valor. Se este for nulo então é atribuido
  ao registo pc o endereço correspondente à label, incrementa
  simplesmente pc de 1, caso contrário.
    \\ \hline 

  PUSHA & label etiqueta &  empilha o endereço de programa correspondente a etiqueta
  label
  \\ \hline 

  CALL &  & retira da pilha um endereço de programa a, salvaguarda pc e fp na
  pilha das chamadas, afecta a fp o valor corrente de sp e a pc o valor
  de a.
  \\ \hline 
  RETURN & &  afecta a sp o valor corrente de fp, restaura da pilha de chamadas
  os valores de fp e de pc, incrementa pc de 1 por forma a encontrar
  a instrução a seguir a chamada.
  \\ \hline 
  \end{tabular}
  \end{table}

  \subsubsection{Inicialização e fim}

 \begin{table}[H]
    \label{table:inicializacao}
\centering
  \begin{tabular}{ | L{2cm} | L{2cm} |  R{10cm} | }
  \hline
  Instrução &  Argumentos & Descrição
  \\ \hline \hline

  START &  &  Afecta o valor de sp a fp
  \\ \hline 
  NOP &  & não faz nada.
  \\ \hline 
  ERR & x string &  levanta um erro com a mensagem x.
  \\ \hline 
  STOP & &  pára a execução do programa
  \\ \hline 

  \end{tabular}
  \end{table}

  \subsubsection{Operações necessárias e não presentes em instruções da VM}

Existem operações lógicas e relacionais que não estão disponíveis na VM, nomeadamente:

\begin{itemize}
\item Negação Lógica
\item OR Lógico
\item AND Lógico
\item NOT EQUAL Lógico
\end{itemize}

No entanto recorrendo a instruções presentes nas tabelas \ref{table:operacoes_inteiros} e \ref{table:manipular_dados}, referentes a operações sobre inteiros e a manipulação de dados, conseguimos obter o comportamento lógico dessas mesmas operações.\par 
Relativamente às instruções de controlo de fluxo seria útil a presença da instrução \textbf{jnz} 
que deveria retirar da pilha um valor e se esse fosse não nulo então seria atribuído  ao registo pc o endereço correspondente à label. No entanto esta lacuna é também contornável como veremos nas secções seguintes do relatório.


  \chapter{Geração de Código Máquina -- de Produções a Assembly }


Especificadas as instruções disponíveis na máquina virtual, assim como a sua forma de funcionamento, resta-nos incluir nas produções da gramática independente de contexto a geração de código máquina correspondente. 

\section{Métodos e variáveis auxiliares à geração de código máquina}
Por forma a implementar correctamente as funcionalidades propostas, é necessário o conhecimento de alguns dados gerais do programa a ser analisado. \par 
Relativamente às variáveis necessitamos de possuir informação relativamente ao seu tipo (se é inteiro atómico, array, matriz ou função), tamanho total ocupado, dimensões (quando aplicável), 	e posição relativamente ao global pointer.\par 
Ora tal informação é guardada no array de estruturas var\_table, que possui capacidade para armazenar dados relativos a 1000 variáveis. O array \textbf{ia[x]}\footnote{Tal solução foi pensada tendo por base forma de representação de matrizes esparsas CSR, daí advindo o nome da variável.} permite de forma rápida saber qual o tamanho total ocupado pela variável presente no índice x da var\_table.\par
 É mantido também estado sobre o número de condicionais e ciclos abertos e declarados até ao momento.\par
 De seguida apresentam-se todas a variáveis auxiliares assim como a assinatura das funções às quais se recorre para implementar todas as funcionalidades.
 
   \lstinputlisting[language=C]{yacc/algebric_code.y} %input de um ficheiro

À medida que formos recorrendo às funções auxiliares iremos apresentar o respectivo código C.

\section{Geração de código máquina nas produções}

\subsection{Início e término do programa}
Comecemos pela inclusão das instruções \textbf{START} e \textbf{STOP}. Estas iniciam e param a máquina virtual. Assim sendo, as mesmas serão incluídas na produção:

  \lstinputlisting[language=Yacc]{yacc/yacc_6_start_stop.y} %input de um ficheiro

Sendo o seguinte código associado à produção:

  \lstinputlisting[language=Yacc]{yacc/yacc_6_start_stop_code.y} %input de um ficheiro

\subsection{Declarações de variáveis}
Sempre que são reconhecidas as produções de declarações de variáveis é necessário alocar o espaço correspondente às mesmas na stack. Ora, assim sendo, o conjunto de instruções de código máquina que permitirão a correcta declaração de variáveis será incluído nas produções:
\lstinputlisting[language=Yacc]{yacc/yacc_7_declaracao.y} %input de um ficheiro

Sendo o seguinte código associado à produção:
\lstinputlisting[language=Yacc]{yacc/yacc_7_declaracao_code.y} %input de um ficheiro


















\chapter{ Testes às funcionalidades da Algebra}


  \chapter{Conclusão}
  \label{concl}

  Relativamente ao estado final do projecto acredito que foram cumpridos todos os requisitos, sendo que o segundo exercício foi sem dúvida o mais desafiante dada a enorme quantidade de dados e o tipo de dados em si a serem analisados. Reconhecer por si só quais as sequências de caracteres  válidas foi um desafio.\par Naturalmente que a partir da alínea 2.2.b a alínea 2.2.c foi de extrema facilidade, uma vez que todo o trabalho de análise já estava realizado. \par 
  Foi ainda tido em conta a possiblidade de recuperar de erros de leitura na alínea 2.2.b o que facilitou o input correct de dados e posterior tratamento.
  O recurso à biblioteca Glib, recomendada pelo professor José João num aula laboratorial permitiu-me ambientar ainda mais com código desenvolvido por terceiros  e sua correcta análise e integração nos meus projectos.\par 
  Faço um balanço positivo do trabalho prático, pois, apesar de ser extremamente "time consuming" retirei muito conhecimento no que da análise de dados e processamento de linguagens diz respeito.

  \appendix
  \chapter{Código do Programa da alínea 1a}
  \label{completo1a}
  % \lstinputlisting{owl_graph.l} %input de um ficheiro

  \newpage
  \chapter{Código do Programa da alínea 2a}
  \label{completo2a}
  %    \lstinputlisting{bib_norm_1.l} %input de um ficheiro

  \newpage
  \chapter{Código do Programa da alínea 2b}
  \label{completo2b}
  %  \lstinputlisting{bib_norm_2.l} %input de um ficheiro

  \newpage
  \chapter{Código do Programa da alínea 3a}
  \label{completo2c}
  %   \lstinputlisting{bib_norm_3.l} %input de um ficheiro

  \end{document}
